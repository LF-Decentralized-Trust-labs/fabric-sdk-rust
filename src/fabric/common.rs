// This file is @generated by prost-build.
/// MSPPrincipal aims to represent an MSP-centric set of identities.
/// In particular, this structure allows for definition of
///   - a group of identities that are member of the same MSP
///   - a group of identities that are member of the same organization unit
///     in the same MSP
///   - a group of identities that are administering a specific MSP
///   - a specific identity
/// Expressing these groups is done given two fields of the fields below
///   - Classification, that defines the type of classification of identities
///     in an MSP this principal would be defined on; Classification can take
///     three values:
///      (i)  ByMSPRole: that represents a classification of identities within
///           MSP based on one of the two pre-defined MSP rules, "member" and "admin"
///      (ii) ByOrganizationUnit: that represents a classification of identities
///           within MSP based on the organization unit an identity belongs to
///      (iii)ByIdentity that denotes that MSPPrincipal is mapped to a single
///           identity/certificate; this would mean that the Principal bytes
///           message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MspPrincipal {
    /// Classification describes the way that one should process
    /// Principal. An Classification value of "ByOrganizationUnit" reflects
    /// that "Principal" contains the name of an organization this MSP
    /// handles. A Classification value "ByIdentity" means that
    /// "Principal" contains a specific identity. Default value
    /// denotes that Principal contains one of the groups by
    /// default supported by all MSPs ("admin" or "member").
    #[prost(enumeration = "msp_principal::Classification", tag = "1")]
    pub principal_classification: i32,
    /// Principal completes the policy principal definition. For the default
    /// principal types, Principal can be either "Admin" or "Member".
    /// For the ByOrganizationUnit/ByIdentity values of Classification,
    /// PolicyPrincipal acquires its value from an organization unit or
    /// identity, respectively.
    /// For the Combined Classification type, the Principal is a marshalled
    /// CombinedPrincipal.
    #[prost(bytes = "vec", tag = "2")]
    pub principal: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `MSPPrincipal`.
pub mod msp_principal {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Classification {
        /// Represents the one of the dedicated MSP roles, the
        Role = 0,
        /// one of a member of MSP network, and the one of an
        /// administrator of an MSP network
        ///
        /// Denotes a finer grained (affiliation-based)
        OrganizationUnit = 1,
        /// groupping of entities, per MSP affiliation
        /// E.g., this can well be represented by an MSP's
        /// Organization unit
        ///
        /// Denotes a principal that consists of a single
        Identity = 2,
        /// identity
        ///
        /// Denotes a principal that can be used to enforce
        Anonymity = 3,
        /// an identity to be anonymous or nominal.
        ///
        /// Denotes a combined principal
        Combined = 4,
    }
    impl Classification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Role => "ROLE",
                Self::OrganizationUnit => "ORGANIZATION_UNIT",
                Self::Identity => "IDENTITY",
                Self::Anonymity => "ANONYMITY",
                Self::Combined => "COMBINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE" => Some(Self::Role),
                "ORGANIZATION_UNIT" => Some(Self::OrganizationUnit),
                "IDENTITY" => Some(Self::Identity),
                "ANONYMITY" => Some(Self::Anonymity),
                "COMBINED" => Some(Self::Combined),
                _ => None,
            }
        }
    }
}
/// OrganizationUnit governs the organization of the Principal
/// field of a policy principal when a specific organization unity members
/// are to be defined within a policy principal.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrganizationUnit {
    /// MSPIdentifier represents the identifier of the MSP this organization unit
    /// refers to
    #[prost(string, tag = "1")]
    pub msp_identifier: ::prost::alloc::string::String,
    /// OrganizationUnitIdentifier defines the organizational unit under the
    /// MSP identified with MSPIdentifier
    #[prost(string, tag = "2")]
    pub organizational_unit_identifier: ::prost::alloc::string::String,
    /// CertifiersIdentifier is the hash of certificates chain of trust
    /// related to this organizational unit
    #[prost(bytes = "vec", tag = "3")]
    pub certifiers_identifier: ::prost::alloc::vec::Vec<u8>,
}
/// MSPRole governs the organization of the Principal
/// field of an MSPPrincipal when it aims to define one of the
/// two dedicated roles within an MSP: Admin and Members.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MspRole {
    /// MSPIdentifier represents the identifier of the MSP this principal
    /// refers to
    #[prost(string, tag = "1")]
    pub msp_identifier: ::prost::alloc::string::String,
    /// MSPRoleType defines which of the available, pre-defined MSP-roles
    /// an identiy should posess inside the MSP with identifier MSPidentifier
    #[prost(enumeration = "msp_role::MspRoleType", tag = "2")]
    pub role: i32,
}
/// Nested message and enum types in `MSPRole`.
pub mod msp_role {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MspRoleType {
        /// Represents an MSP Member
        Member = 0,
        /// Represents an MSP Admin
        Admin = 1,
        /// Represents an MSP Client
        Client = 2,
        /// Represents an MSP Peer
        Peer = 3,
        /// Represents an MSP Orderer
        Orderer = 4,
    }
    impl MspRoleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Member => "MEMBER",
                Self::Admin => "ADMIN",
                Self::Client => "CLIENT",
                Self::Peer => "PEER",
                Self::Orderer => "ORDERER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEMBER" => Some(Self::Member),
                "ADMIN" => Some(Self::Admin),
                "CLIENT" => Some(Self::Client),
                "PEER" => Some(Self::Peer),
                "ORDERER" => Some(Self::Orderer),
                _ => None,
            }
        }
    }
}
/// MSPIdentityAnonymity can be used to enforce an identity to be anonymous or nominal.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MspIdentityAnonymity {
    #[prost(enumeration = "msp_identity_anonymity::MspIdentityAnonymityType", tag = "1")]
    pub anonymity_type: i32,
}
/// Nested message and enum types in `MSPIdentityAnonymity`.
pub mod msp_identity_anonymity {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MspIdentityAnonymityType {
        /// Represents a nominal MSP Identity
        Nominal = 0,
        /// Represents an anonymous MSP Identity
        Anonymous = 1,
    }
    impl MspIdentityAnonymityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Nominal => "NOMINAL",
                Self::Anonymous => "ANONYMOUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOMINAL" => Some(Self::Nominal),
                "ANONYMOUS" => Some(Self::Anonymous),
                _ => None,
            }
        }
    }
}
/// CombinedPrincipal governs the organization of the Principal
/// field of a policy principal when principal_classification has
/// indicated that a combined form of principals is required
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CombinedPrincipal {
    /// Principals refer to combined principals
    #[prost(message, repeated, tag = "1")]
    pub principals: ::prost::alloc::vec::Vec<MspPrincipal>,
}
/// Policy expresses a policy which the orderer can evaluate, because there has been some desire expressed to support
/// multiple policy engines, this is typed as a oneof for now
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Policy {
    /// For outside implementors, consider the first 1000 types reserved, otherwise one of PolicyType
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `Policy`.
pub mod policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyType {
        /// Reserved to check for proper initialization
        Unknown = 0,
        Signature = 1,
        Msp = 2,
        ImplicitMeta = 3,
    }
    impl PolicyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Signature => "SIGNATURE",
                Self::Msp => "MSP",
                Self::ImplicitMeta => "IMPLICIT_META",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "SIGNATURE" => Some(Self::Signature),
                "MSP" => Some(Self::Msp),
                "IMPLICIT_META" => Some(Self::ImplicitMeta),
                _ => None,
            }
        }
    }
}
/// SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignaturePolicyEnvelope {
    #[prost(int32, tag = "1")]
    pub version: i32,
    #[prost(message, optional, tag = "2")]
    pub rule: ::core::option::Option<SignaturePolicy>,
    #[prost(message, repeated, tag = "3")]
    pub identities: ::prost::alloc::vec::Vec<MspPrincipal>,
}
/// SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
/// policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
/// to express AND as well as OR, as well as of course N out of the following M policies
/// SignedBy implies that the signature is from a valid certificate which is signed by the trusted
/// authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
/// and will be the CA for more traditional certificates
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignaturePolicy {
    #[prost(oneof = "signature_policy::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<signature_policy::Type>,
}
/// Nested message and enum types in `SignaturePolicy`.
pub mod signature_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NOutOf {
        #[prost(int32, tag = "1")]
        pub n: i32,
        #[prost(message, repeated, tag = "2")]
        pub rules: ::prost::alloc::vec::Vec<super::SignaturePolicy>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(int32, tag = "1")]
        SignedBy(i32),
        #[prost(message, tag = "2")]
        NOutOf(NOutOf),
    }
}
/// ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration
/// It is implicit because the rule is generate implicitly based on the number of sub policies
/// It is meta because it depends only on the result of other policies
/// When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy
/// of name sub_policy, evaluates the collection and applies the rule.
/// For example, with 4 sub-groups, and a policy name of "foo", ImplicitMetaPolicy retrieves
/// each sub-group, retrieves policy "foo" for each subgroup, evaluates it, and, in the case of ANY
/// 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImplicitMetaPolicy {
    #[prost(string, tag = "1")]
    pub sub_policy: ::prost::alloc::string::String,
    #[prost(enumeration = "implicit_meta_policy::Rule", tag = "2")]
    pub rule: i32,
}
/// Nested message and enum types in `ImplicitMetaPolicy`.
pub mod implicit_meta_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Rule {
        /// Requires any of the sub-policies be satisfied, if no sub-policies exist, always returns true
        Any = 0,
        /// Requires all of the sub-policies be satisfied
        All = 1,
        /// Requires a strict majority (greater than half) of the sub-policies be satisfied
        Majority = 2,
    }
    impl Rule {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Any => "ANY",
                Self::All => "ALL",
                Self::Majority => "MAJORITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANY" => Some(Self::Any),
                "ALL" => Some(Self::All),
                "MAJORITY" => Some(Self::Majority),
                _ => None,
            }
        }
    }
}
/// ApplicationPolicy captures the diffenrent policy types that
/// are set and evaluted at the application level.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationPolicy {
    #[prost(oneof = "application_policy::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<application_policy::Type>,
}
/// Nested message and enum types in `ApplicationPolicy`.
pub mod application_policy {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// SignaturePolicy type is used if the policy is specified as
        /// a combination (using threshold gates) of signatures from MSP
        /// principals
        #[prost(message, tag = "1")]
        SignaturePolicy(super::SignaturePolicyEnvelope),
        /// ChannelConfigPolicyReference is used when the policy is
        /// specified as a string that references a policy defined in
        /// the configuration of the channel
        #[prost(string, tag = "2")]
        ChannelConfigPolicyReference(::prost::alloc::string::String),
    }
}
/// LastConfig is the encoded value for the Metadata message which is encoded in the LAST_CONFIGURATION block metadata index
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LastConfig {
    #[prost(uint64, tag = "1")]
    pub index: u64,
}
/// Metadata is a common structure to be used to encode block metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<MetadataSignature>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MetadataSignature {
    /// An encoded SignatureHeader
    #[prost(bytes = "vec", tag = "1")]
    pub signature_header: ::prost::alloc::vec::Vec<u8>,
    /// The signature over the concatenation of the Metadata value bytes, signatureHeader, and block header
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// An encoded IdentifierHeader. If the signature header is empty, this is used to identify the creator by id
    #[prost(bytes = "vec", tag = "3")]
    pub identifier_header: ::prost::alloc::vec::Vec<u8>,
}
/// IdentifierHeader is used as an alternative to a SignatureHeader when the creator can be referenced by id
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IdentifierHeader {
    /// A unique identifier that represents the creator of the message
    #[prost(uint32, tag = "1")]
    pub identifier: u32,
    /// Arbitrary number that may only be used once. Can be used to detect replay attacks.
    #[prost(bytes = "vec", tag = "2")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Header {
    #[prost(bytes = "vec", tag = "1")]
    pub channel_header: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub signature_header: ::prost::alloc::vec::Vec<u8>,
}
/// Header is a generic replay prevention and identity message to include in a signed payload
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChannelHeader {
    /// Header types 0-10000 are reserved and defined by HeaderType
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    /// Version indicates message protocol version
    #[prost(int32, tag = "2")]
    pub version: i32,
    /// Timestamp is the local time when the message was created
    /// by the sender
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Identifier of the channel this message is bound for
    #[prost(string, tag = "4")]
    pub channel_id: ::prost::alloc::string::String,
    /// An unique identifier that is used end-to-end.
    ///   -  set by higher layers such as end user or SDK
    ///   -  passed to the endorser (which will check for uniqueness)
    ///   -  as the header is passed along unchanged, it will be
    ///      be retrieved by the committer (uniqueness check here as well)
    ///   -  to be stored in the ledger
    #[prost(string, tag = "5")]
    pub tx_id: ::prost::alloc::string::String,
    /// The epoch in which this header was generated, where epoch is defined based on block height
    /// Epoch in which the response has been generated. This field identifies a
    /// logical window of time. A proposal response is accepted by a peer only if
    /// two conditions hold:
    /// 1. the epoch specified in the message is the current epoch
    /// 2. this message has been only seen once during this epoch (i.e. it hasn't
    ///     been replayed)
    #[prost(uint64, tag = "6")]
    pub epoch: u64,
    /// Extension that may be attached based on the header type
    #[prost(bytes = "vec", tag = "7")]
    pub extension: ::prost::alloc::vec::Vec<u8>,
    /// If mutual TLS is employed, this represents
    /// the hash of the client's TLS certificate
    #[prost(bytes = "vec", tag = "8")]
    pub tls_cert_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignatureHeader {
    /// Creator of the message, a marshaled msp.SerializedIdentity
    #[prost(bytes = "vec", tag = "1")]
    pub creator: ::prost::alloc::vec::Vec<u8>,
    /// Arbitrary number that may only be used once. Can be used to detect replay attacks.
    #[prost(bytes = "vec", tag = "2")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
}
/// Payload is the message contents (and header to allow for signing)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Payload {
    /// Header is included to provide identity and prevent replay
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<Header>,
    /// Data, the encoding of which is defined by the type in the header
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Envelope wraps a Payload with a signature so that the message may be authenticated
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Envelope {
    /// A marshaled Payload
    #[prost(bytes = "vec", tag = "1")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// A signature by the creator specified in the Payload header
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// This is finalized block structure to be shared among the orderer and peer
/// Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
/// in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
/// the Metadata is not.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Block {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<BlockData>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<BlockMetadata>,
}
/// BlockHeader is the element of the block which forms the block chain
/// The block header is hashed using the configured chain hashing algorithm
/// over the ASN.1 encoding of the BlockHeader
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockHeader {
    /// The position in the blockchain
    #[prost(uint64, tag = "1")]
    pub number: u64,
    /// The hash of the previous block header
    #[prost(bytes = "vec", tag = "2")]
    pub previous_hash: ::prost::alloc::vec::Vec<u8>,
    /// The hash of the BlockData, by MerkleTree
    #[prost(bytes = "vec", tag = "3")]
    pub data_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockData {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockMetadata {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub metadata: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// OrdererBlockMetadata defines metadata that is set by the ordering service.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrdererBlockMetadata {
    #[prost(message, optional, tag = "1")]
    pub last_config: ::core::option::Option<LastConfig>,
    #[prost(bytes = "vec", tag = "2")]
    pub consenter_metadata: ::prost::alloc::vec::Vec<u8>,
}
/// These status codes are intended to resemble selected HTTP status codes
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
    Unknown = 0,
    Success = 200,
    BadRequest = 400,
    Forbidden = 403,
    NotFound = 404,
    RequestEntityTooLarge = 413,
    InternalServerError = 500,
    NotImplemented = 501,
    ServiceUnavailable = 503,
}
impl Status {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::Success => "SUCCESS",
            Self::BadRequest => "BAD_REQUEST",
            Self::Forbidden => "FORBIDDEN",
            Self::NotFound => "NOT_FOUND",
            Self::RequestEntityTooLarge => "REQUEST_ENTITY_TOO_LARGE",
            Self::InternalServerError => "INTERNAL_SERVER_ERROR",
            Self::NotImplemented => "NOT_IMPLEMENTED",
            Self::ServiceUnavailable => "SERVICE_UNAVAILABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "SUCCESS" => Some(Self::Success),
            "BAD_REQUEST" => Some(Self::BadRequest),
            "FORBIDDEN" => Some(Self::Forbidden),
            "NOT_FOUND" => Some(Self::NotFound),
            "REQUEST_ENTITY_TOO_LARGE" => Some(Self::RequestEntityTooLarge),
            "INTERNAL_SERVER_ERROR" => Some(Self::InternalServerError),
            "NOT_IMPLEMENTED" => Some(Self::NotImplemented),
            "SERVICE_UNAVAILABLE" => Some(Self::ServiceUnavailable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HeaderType {
    /// Used for messages which are signed but opaque
    Message = 0,
    /// Used for messages which express the channel config
    Config = 1,
    /// Used for transactions which update the channel config
    ConfigUpdate = 2,
    /// Used by the SDK to submit endorser based transactions
    EndorserTransaction = 3,
    /// Was used internally by the orderer for management, no longer used since system channel was removed
    OrdererTransaction = 4,
    /// Used as the type for Envelope messages submitted to instruct the Deliver API to seek
    DeliverSeekInfo = 5,
    /// Used for packaging chaincode artifacts for install
    ChaincodePackage = 6,
}
impl HeaderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Message => "MESSAGE",
            Self::Config => "CONFIG",
            Self::ConfigUpdate => "CONFIG_UPDATE",
            Self::EndorserTransaction => "ENDORSER_TRANSACTION",
            Self::OrdererTransaction => "ORDERER_TRANSACTION",
            Self::DeliverSeekInfo => "DELIVER_SEEK_INFO",
            Self::ChaincodePackage => "CHAINCODE_PACKAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE" => Some(Self::Message),
            "CONFIG" => Some(Self::Config),
            "CONFIG_UPDATE" => Some(Self::ConfigUpdate),
            "ENDORSER_TRANSACTION" => Some(Self::EndorserTransaction),
            "ORDERER_TRANSACTION" => Some(Self::OrdererTransaction),
            "DELIVER_SEEK_INFO" => Some(Self::DeliverSeekInfo),
            "CHAINCODE_PACKAGE" => Some(Self::ChaincodePackage),
            _ => None,
        }
    }
}
/// This enum enlists indexes of the block metadata array
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlockMetadataIndex {
    /// Block metadata array position for block signatures
    Signatures = 0,
    /// Block metadata array position to store last configuration block sequence number
    LastConfig = 1,
    /// Block metadata array position to store serialized bit array filter of invalid transactions
    TransactionsFilter = 2,
    /// Block metadata array position to store operational metadata for orderers
    Orderer = 3,
    /// Block metadata array position to store the hash of TRANSACTIONS_FILTER, State Updates,
    /// and the COMMIT_HASH of the previous block
    CommitHash = 4,
}
impl BlockMetadataIndex {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Signatures => "SIGNATURES",
            Self::LastConfig => "LAST_CONFIG",
            Self::TransactionsFilter => "TRANSACTIONS_FILTER",
            Self::Orderer => "ORDERER",
            Self::CommitHash => "COMMIT_HASH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNATURES" => Some(Self::Signatures),
            "LAST_CONFIG" => Some(Self::LastConfig),
            "TRANSACTIONS_FILTER" => Some(Self::TransactionsFilter),
            "ORDERER" => Some(Self::Orderer),
            "COMMIT_HASH" => Some(Self::CommitHash),
            _ => None,
        }
    }
}
