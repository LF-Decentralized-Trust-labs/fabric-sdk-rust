// This file is @generated by prost-build.
/// ChaincodeEvent is used for events and registrations that are specific to chaincode
/// string type - "chaincode"
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChaincodeEvent {
    #[prost(string, tag = "1")]
    pub chaincode_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub event_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeID contains the path as specified by the deploy transaction
/// that created it as well as the hashCode that is generated by the
/// system for the path. From the user level (ie, CLI, REST API and so on)
/// deploy transaction is expected to provide the path and other requests
/// are expected to provide the hashCode. The other value will be ignored.
/// Internally, the structure could contain both values. For instance, the
/// hashCode will be set when first generated using the path
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChaincodeId {
    /// deploy transaction will use the path
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// all other requests will use the name (really a hashcode) generated by
    /// the deploy transaction
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// user friendly version name for the chaincode
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
}
/// Carries the chaincode function and its arguments.
/// UnmarshalJSON in transaction.go converts the string-based REST/JSON input to
/// the \[\]byte-based current ChaincodeInput structure.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeInput {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(map = "string, bytes", tag = "2")]
    pub decorations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// is_init is used for the application to signal that an invocation is to be routed
    /// to the legacy 'Init' function for compatibility with chaincodes which handled
    /// Init in the old way.  New applications should manage their initialized state
    /// themselves.
    #[prost(bool, tag = "3")]
    pub is_init: bool,
}
/// Carries the chaincode specification. This is the actual metadata required for
/// defining a chaincode.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeSpec {
    #[prost(enumeration = "chaincode_spec::Type", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub chaincode_id: ::core::option::Option<ChaincodeId>,
    #[prost(message, optional, tag = "3")]
    pub input: ::core::option::Option<ChaincodeInput>,
    #[prost(int32, tag = "4")]
    pub timeout: i32,
}
/// Nested message and enum types in `ChaincodeSpec`.
pub mod chaincode_spec {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Undefined = 0,
        Golang = 1,
        Node = 2,
        Car = 3,
        Java = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::Golang => "GOLANG",
                Self::Node => "NODE",
                Self::Car => "CAR",
                Self::Java => "JAVA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "GOLANG" => Some(Self::Golang),
                "NODE" => Some(Self::Node),
                "CAR" => Some(Self::Car),
                "JAVA" => Some(Self::Java),
                _ => None,
            }
        }
    }
}
/// Specify the deployment of a chaincode.
/// TODO: Define `codePackage`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeDeploymentSpec {
    #[prost(message, optional, tag = "1")]
    pub chaincode_spec: ::core::option::Option<ChaincodeSpec>,
    #[prost(bytes = "vec", tag = "3")]
    pub code_package: ::prost::alloc::vec::Vec<u8>,
}
/// Carries the chaincode function and its arguments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeInvocationSpec {
    #[prost(message, optional, tag = "1")]
    pub chaincode_spec: ::core::option::Option<ChaincodeSpec>,
}
/// LifecycleEvent is used as the payload of the chaincode event emitted by LSCC
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LifecycleEvent {
    #[prost(string, tag = "1")]
    pub chaincode_name: ::prost::alloc::string::String,
}
/// CDSData is data stored in the LSCC on instantiation of a CC
/// for CDSPackage.  This needs to be serialized for ChaincodeData
/// hence the protobuf format
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CdsData {
    /// hash of ChaincodeDeploymentSpec.code_package
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// hash of ChaincodeID.name + ChaincodeID.version
    #[prost(bytes = "vec", tag = "2")]
    pub metadatahash: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeData defines the datastructure for chaincodes to be serialized by proto
/// Type provides an additional check by directing to use a specific package after instantiation
/// Data is Type specific (see CDSPackage and SignedCDSPackage)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeData {
    /// Name of the chaincode
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Version of the chaincode
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Escc for the chaincode instance
    #[prost(string, tag = "3")]
    pub escc: ::prost::alloc::string::String,
    /// Vscc for the chaincode instance
    #[prost(string, tag = "4")]
    pub vscc: ::prost::alloc::string::String,
    /// Policy endorsement policy for the chaincode instance
    #[prost(message, optional, tag = "5")]
    pub policy: ::core::option::Option<super::common::SignaturePolicyEnvelope>,
    /// Data data specific to the package
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Id of the chaincode that's the unique fingerprint for the CC This is not
    /// currently used anywhere but serves as a good eyecatcher
    #[prost(bytes = "vec", tag = "7")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// InstantiationPolicy for the chaincode
    #[prost(message, optional, tag = "8")]
    pub instantiation_policy: ::core::option::Option<
        super::common::SignaturePolicyEnvelope,
    >,
}
/// ChaincodeAdditionalParams - parameters passed to chaincode to notify about peer capabilities
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChaincodeAdditionalParams {
    /// an indication that the peer can handle state write batches
    #[prost(bool, tag = "1")]
    pub use_write_batch: bool,
    /// maximum size of batches with write state
    #[prost(uint32, tag = "2")]
    pub max_size_write_batch: u32,
    /// an indication that the peer can handle get multiple keys
    #[prost(bool, tag = "3")]
    pub use_get_multiple_keys: bool,
    /// maximum size of batches with get multiple keys
    #[prost(uint32, tag = "4")]
    pub max_size_get_multiple_keys: u32,
}
/// A ProposalResponse is returned from an endorser to the proposal submitter.
/// The idea is that this message contains the endorser's response to the
/// request of a client to perform an action over a chaincode (or more
/// generically on the ledger); the response might be success/error (conveyed in
/// the Response field) together with a description of the action and a
/// signature over it by that endorser.  If a sufficient number of distinct
/// endorsers agree on the same action and produce signature to that effect, a
/// transaction can be generated and sent for ordering.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalResponse {
    /// Version indicates message protocol version
    #[prost(int32, tag = "1")]
    pub version: i32,
    /// Timestamp is the time that the message
    /// was created as  defined by the sender
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// A response message indicating whether the
    /// endorsement of the action was successful
    #[prost(message, optional, tag = "4")]
    pub response: ::core::option::Option<Response>,
    /// The payload of response. It is the bytes of ProposalResponsePayload
    #[prost(bytes = "vec", tag = "5")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// The endorsement of the proposal, basically
    /// the endorser's signature over the payload
    #[prost(message, optional, tag = "6")]
    pub endorsement: ::core::option::Option<Endorsement>,
    /// The chaincode interest derived from simulating the proposal.
    #[prost(message, optional, tag = "7")]
    pub interest: ::core::option::Option<ChaincodeInterest>,
}
/// A response with a representation similar to an HTTP response that can
/// be used within another message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Response {
    /// A status code that should follow the HTTP status codes.
    #[prost(int32, tag = "1")]
    pub status: i32,
    /// A message associated with the response code.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// A payload that can be used to include metadata with this response.
    #[prost(bytes = "vec", tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// ProposalResponsePayload is the payload of a proposal response.  This message
/// is the "bridge" between the client's request and the endorser's action in
/// response to that request. Concretely, for chaincodes, it contains a hashed
/// representation of the proposal (proposalHash) and a representation of the
/// chaincode state changes and events inside the extension field.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProposalResponsePayload {
    /// Hash of the proposal that triggered this response. The hash is used to
    /// link a response with its proposal, both for bookeeping purposes on an
    /// asynchronous system and for security reasons (accountability,
    /// non-repudiation). The hash usually covers the entire Proposal message
    /// (byte-by-byte).
    #[prost(bytes = "vec", tag = "1")]
    pub proposal_hash: ::prost::alloc::vec::Vec<u8>,
    /// Extension should be unmarshaled to a type-specific message. The type of
    /// the extension in any proposal response depends on the type of the proposal
    /// that the client selected when the proposal was initially sent out.  In
    /// particular, this information is stored in the type field of a Header.  For
    /// chaincode, it's a ChaincodeAction message
    #[prost(bytes = "vec", tag = "2")]
    pub extension: ::prost::alloc::vec::Vec<u8>,
}
/// An endorsement is a signature of an endorser over a proposal response.  By
/// producing an endorsement message, an endorser implicitly "approves" that
/// proposal response and the actions contained therein. When enough
/// endorsements have been collected, a transaction can be generated out of a
/// set of proposal responses.  Note that this message only contains an identity
/// and a signature but no signed payload. This is intentional because
/// endorsements are supposed to be collected in a transaction, and they are all
/// expected to endorse a single proposal response/action (many endorsements
/// over a single proposal response)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Endorsement {
    /// Identity of the endorser (e.g. its certificate)
    #[prost(bytes = "vec", tag = "1")]
    pub endorser: ::prost::alloc::vec::Vec<u8>,
    /// Signature of the payload included in ProposalResponse concatenated with
    /// the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeInterest defines an interest about an endorsement
/// for a specific single chaincode invocation.
/// Multiple chaincodes indicate chaincode to chaincode invocations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeInterest {
    #[prost(message, repeated, tag = "1")]
    pub chaincodes: ::prost::alloc::vec::Vec<ChaincodeCall>,
}
/// ChaincodeCall defines a call to a chaincode.
/// It may have collections that are related to the chaincode
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeCall {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub collection_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Indicates we do not need to read from private data
    #[prost(bool, tag = "3")]
    pub no_private_reads: bool,
    /// Indicates we do not need to write to the chaincode namespace
    #[prost(bool, tag = "4")]
    pub no_public_writes: bool,
    /// The set of signature policies associated with states in the write-set
    /// that have state-based endorsement policies.
    #[prost(message, repeated, tag = "5")]
    pub key_policies: ::prost::alloc::vec::Vec<super::common::SignaturePolicyEnvelope>,
    /// Indicates we wish to ignore the namespace endorsement policy
    #[prost(bool, tag = "6")]
    pub disregard_namespace_policy: bool,
}
/// This structure is necessary to sign the proposal which contains the header
/// and the payload. Without this structure, we would have to concatenate the
/// header and the payload to verify the signature, which could be expensive
/// with large payload
///
/// When an endorser receives a SignedProposal message, it should verify the
/// signature over the proposal bytes. This verification requires the following
/// steps:
/// 1. Verification of the validity of the certificate that was used to produce
///     the signature.  The certificate will be available once proposalBytes has
///     been unmarshalled to a Proposal message, and Proposal.header has been
///     unmarshalled to a Header message. While this unmarshalling-before-verifying
///     might not be ideal, it is unavoidable because i) the signature needs to also
///     protect the signing certificate; ii) it is desirable that Header is created
///     once by the client and never changed (for the sake of accountability and
///     non-repudiation). Note also that it is actually impossible to conclusively
///     verify the validity of the certificate included in a Proposal, because the
///     proposal needs to first be endorsed and ordered with respect to certificate
///     expiration transactions. Still, it is useful to pre-filter expired
///     certificates at this stage.
/// 2. Verification that the certificate is trusted (signed by a trusted CA) and
///     that it is allowed to transact with us (with respect to some ACLs);
/// 3. Verification that the signature on proposalBytes is valid;
/// 4. Detect replay attacks;
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignedProposal {
    /// The bytes of Proposal
    #[prost(bytes = "vec", tag = "1")]
    pub proposal_bytes: ::prost::alloc::vec::Vec<u8>,
    /// Signaure over proposalBytes; this signature is to be verified against
    /// the creator identity contained in the header of the Proposal message
    /// marshaled as proposalBytes
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// A Proposal is sent to an endorser for endorsement.  The proposal contains:
/// 1. A header which should be unmarshaled to a Header message.  Note that
///     Header is both the header of a Proposal and of a Transaction, in that i)
///     both headers should be unmarshaled to this message; and ii) it is used to
///     compute cryptographic hashes and signatures.  The header has fields common
///     to all proposals/transactions.  In addition it has a type field for
///     additional customization. An example of this is the ChaincodeHeaderExtension
///     message used to extend the Header for type CHAINCODE.
/// 2. A payload whose type depends on the header's type field.
/// 3. An extension whose type depends on the header's type field.
///
/// Let us see an example. For type CHAINCODE (see the Header message),
/// we have the following:
/// 1. The header is a Header message whose extensions field is a
///     ChaincodeHeaderExtension message.
/// 2. The payload is a ChaincodeProposalPayload message.
/// 3. The extension is a ChaincodeAction that might be used to ask the
///     endorsers to endorse a specific ChaincodeAction, thus emulating the
///     submitting peer model.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Proposal {
    /// The header of the proposal. It is the bytes of the Header
    #[prost(bytes = "vec", tag = "1")]
    pub header: ::prost::alloc::vec::Vec<u8>,
    /// The payload of the proposal as defined by the type in the proposal
    /// header.
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// Optional extensions to the proposal. Its content depends on the Header's
    /// type field.  For the type CHAINCODE, it might be the bytes of a
    /// ChaincodeAction message.
    #[prost(bytes = "vec", tag = "3")]
    pub extension: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeHeaderExtension is the Header's extentions message to be used when
/// the Header's type is CHAINCODE.  This extensions is used to specify which
/// chaincode to invoke and what should appear on the ledger.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChaincodeHeaderExtension {
    /// The ID of the chaincode to target.
    #[prost(message, optional, tag = "2")]
    pub chaincode_id: ::core::option::Option<ChaincodeId>,
}
/// ChaincodeProposalPayload is the Proposal's payload message to be used when
/// the Header's type is CHAINCODE.  It contains the arguments for this
/// invocation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeProposalPayload {
    /// Input contains the arguments for this invocation. If this invocation
    /// deploys a new chaincode, ESCC/VSCC are part of this field.
    /// This is usually a marshaled ChaincodeInvocationSpec
    #[prost(bytes = "vec", tag = "1")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// TransientMap contains data (e.g. cryptographic material) that might be used
    /// to implement some form of application-level confidentiality. The contents
    /// of this field are supposed to always be omitted from the transaction and
    /// excluded from the ledger.
    #[prost(map = "string, bytes", tag = "2")]
    pub transient_map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
/// ChaincodeAction contains the executed chaincode results, response, and event.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChaincodeAction {
    /// This field contains the read set and the write set produced by the
    /// chaincode executing this invocation.
    #[prost(bytes = "vec", tag = "1")]
    pub results: ::prost::alloc::vec::Vec<u8>,
    /// This field contains the event generated by the chaincode.
    /// Only a single marshaled ChaincodeEvent is included.
    #[prost(bytes = "vec", tag = "2")]
    pub events: ::prost::alloc::vec::Vec<u8>,
    /// This field contains the result of executing this invocation.
    #[prost(message, optional, tag = "3")]
    pub response: ::core::option::Option<Response>,
    /// This field contains the ChaincodeID of executing this invocation. Endorser
    /// will set it with the ChaincodeID called by endorser while simulating proposal.
    /// Committer will validate the version matching with latest chaincode version.
    /// Adding ChaincodeID to keep version opens up the possibility of multiple
    /// ChaincodeAction per transaction.
    #[prost(message, optional, tag = "4")]
    pub chaincode_id: ::core::option::Option<ChaincodeId>,
}
/// ProcessedTransaction wraps an Envelope that includes a transaction along with an indication
/// of whether the transaction was validated or invalidated by committing peer.
/// The use case is that GetTransactionByID API needs to retrieve the transaction Envelope
/// from block storage, and return it to a client, and indicate whether the transaction
/// was validated or invalidated by committing peer. So that the originally submitted
/// transaction Envelope is not modified, the ProcessedTransaction wrapper is returned.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProcessedTransaction {
    /// An Envelope which includes a processed transaction
    #[prost(message, optional, tag = "1")]
    pub transaction_envelope: ::core::option::Option<super::common::Envelope>,
    /// An indication of whether the transaction was validated or invalidated by committing peer
    #[prost(int32, tag = "2")]
    pub validation_code: i32,
}
/// The transaction to be sent to the ordering service. A transaction contains
/// one or more TransactionAction. Each TransactionAction binds a proposal to
/// potentially multiple actions. The transaction is atomic meaning that either
/// all actions in the transaction will be committed or none will.  Note that
/// while a Transaction might include more than one Header, the Header.creator
/// field must be the same in each.
/// A single client is free to issue a number of independent Proposal, each with
/// their header (Header) and request payload (ChaincodeProposalPayload).  Each
/// proposal is independently endorsed generating an action
/// (ProposalResponsePayload) with one signature per Endorser. Any number of
/// independent proposals (and their action) might be included in a transaction
/// to ensure that they are treated atomically.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// The payload is an array of TransactionAction. An array is necessary to
    /// accommodate multiple actions per transaction
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<TransactionAction>,
}
/// TransactionAction binds a proposal to its action.  The type field in the
/// header dictates the type of action to be applied to the ledger.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransactionAction {
    /// The header of the proposal action, which is the proposal header
    #[prost(bytes = "vec", tag = "1")]
    pub header: ::prost::alloc::vec::Vec<u8>,
    /// The payload of the action as defined by the type in the header For
    /// chaincode, it's the bytes of ChaincodeActionPayload
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeActionPayload is the message to be used for the TransactionAction's
/// payload when the Header's type is set to CHAINCODE.  It carries the
/// chaincodeProposalPayload and an endorsed action to apply to the ledger.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeActionPayload {
    /// This field contains the bytes of the ChaincodeProposalPayload message from
    /// the original invocation (essentially the arguments) after the application
    /// of the visibility function. The main visibility modes are "full" (the
    /// entire ChaincodeProposalPayload message is included here), "hash" (only
    /// the hash of the ChaincodeProposalPayload message is included) or
    /// "nothing".  This field will be used to check the consistency of
    /// ProposalResponsePayload.proposalHash.  For the CHAINCODE type,
    /// ProposalResponsePayload.proposalHash is supposed to be H(ProposalHeader ||
    /// f(ChaincodeProposalPayload)) where f is the visibility function.
    #[prost(bytes = "vec", tag = "1")]
    pub chaincode_proposal_payload: ::prost::alloc::vec::Vec<u8>,
    /// The list of actions to apply to the ledger
    #[prost(message, optional, tag = "2")]
    pub action: ::core::option::Option<ChaincodeEndorsedAction>,
}
/// ChaincodeEndorsedAction carries information about the endorsement of a
/// specific proposal
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeEndorsedAction {
    /// This is the bytes of the ProposalResponsePayload message signed by the
    /// endorsers.  Recall that for the CHAINCODE type, the
    /// ProposalResponsePayload's extenstion field carries a ChaincodeAction
    #[prost(bytes = "vec", tag = "1")]
    pub proposal_response_payload: ::prost::alloc::vec::Vec<u8>,
    /// The endorsement of the proposal, basically the endorser's signature over
    /// proposalResponsePayload
    #[prost(message, repeated, tag = "2")]
    pub endorsements: ::prost::alloc::vec::Vec<Endorsement>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TxValidationCode {
    Valid = 0,
    NilEnvelope = 1,
    BadPayload = 2,
    BadCommonHeader = 3,
    BadCreatorSignature = 4,
    InvalidEndorserTransaction = 5,
    InvalidConfigTransaction = 6,
    UnsupportedTxPayload = 7,
    BadProposalTxid = 8,
    DuplicateTxid = 9,
    EndorsementPolicyFailure = 10,
    MvccReadConflict = 11,
    PhantomReadConflict = 12,
    UnknownTxType = 13,
    TargetChainNotFound = 14,
    MarshalTxError = 15,
    NilTxaction = 16,
    ExpiredChaincode = 17,
    ChaincodeVersionConflict = 18,
    BadHeaderExtension = 19,
    BadChannelHeader = 20,
    BadResponsePayload = 21,
    BadRwset = 22,
    IllegalWriteset = 23,
    InvalidWriteset = 24,
    InvalidChaincode = 25,
    NotValidated = 254,
    InvalidOtherReason = 255,
}
impl TxValidationCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Valid => "VALID",
            Self::NilEnvelope => "NIL_ENVELOPE",
            Self::BadPayload => "BAD_PAYLOAD",
            Self::BadCommonHeader => "BAD_COMMON_HEADER",
            Self::BadCreatorSignature => "BAD_CREATOR_SIGNATURE",
            Self::InvalidEndorserTransaction => "INVALID_ENDORSER_TRANSACTION",
            Self::InvalidConfigTransaction => "INVALID_CONFIG_TRANSACTION",
            Self::UnsupportedTxPayload => "UNSUPPORTED_TX_PAYLOAD",
            Self::BadProposalTxid => "BAD_PROPOSAL_TXID",
            Self::DuplicateTxid => "DUPLICATE_TXID",
            Self::EndorsementPolicyFailure => "ENDORSEMENT_POLICY_FAILURE",
            Self::MvccReadConflict => "MVCC_READ_CONFLICT",
            Self::PhantomReadConflict => "PHANTOM_READ_CONFLICT",
            Self::UnknownTxType => "UNKNOWN_TX_TYPE",
            Self::TargetChainNotFound => "TARGET_CHAIN_NOT_FOUND",
            Self::MarshalTxError => "MARSHAL_TX_ERROR",
            Self::NilTxaction => "NIL_TXACTION",
            Self::ExpiredChaincode => "EXPIRED_CHAINCODE",
            Self::ChaincodeVersionConflict => "CHAINCODE_VERSION_CONFLICT",
            Self::BadHeaderExtension => "BAD_HEADER_EXTENSION",
            Self::BadChannelHeader => "BAD_CHANNEL_HEADER",
            Self::BadResponsePayload => "BAD_RESPONSE_PAYLOAD",
            Self::BadRwset => "BAD_RWSET",
            Self::IllegalWriteset => "ILLEGAL_WRITESET",
            Self::InvalidWriteset => "INVALID_WRITESET",
            Self::InvalidChaincode => "INVALID_CHAINCODE",
            Self::NotValidated => "NOT_VALIDATED",
            Self::InvalidOtherReason => "INVALID_OTHER_REASON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALID" => Some(Self::Valid),
            "NIL_ENVELOPE" => Some(Self::NilEnvelope),
            "BAD_PAYLOAD" => Some(Self::BadPayload),
            "BAD_COMMON_HEADER" => Some(Self::BadCommonHeader),
            "BAD_CREATOR_SIGNATURE" => Some(Self::BadCreatorSignature),
            "INVALID_ENDORSER_TRANSACTION" => Some(Self::InvalidEndorserTransaction),
            "INVALID_CONFIG_TRANSACTION" => Some(Self::InvalidConfigTransaction),
            "UNSUPPORTED_TX_PAYLOAD" => Some(Self::UnsupportedTxPayload),
            "BAD_PROPOSAL_TXID" => Some(Self::BadProposalTxid),
            "DUPLICATE_TXID" => Some(Self::DuplicateTxid),
            "ENDORSEMENT_POLICY_FAILURE" => Some(Self::EndorsementPolicyFailure),
            "MVCC_READ_CONFLICT" => Some(Self::MvccReadConflict),
            "PHANTOM_READ_CONFLICT" => Some(Self::PhantomReadConflict),
            "UNKNOWN_TX_TYPE" => Some(Self::UnknownTxType),
            "TARGET_CHAIN_NOT_FOUND" => Some(Self::TargetChainNotFound),
            "MARSHAL_TX_ERROR" => Some(Self::MarshalTxError),
            "NIL_TXACTION" => Some(Self::NilTxaction),
            "EXPIRED_CHAINCODE" => Some(Self::ExpiredChaincode),
            "CHAINCODE_VERSION_CONFLICT" => Some(Self::ChaincodeVersionConflict),
            "BAD_HEADER_EXTENSION" => Some(Self::BadHeaderExtension),
            "BAD_CHANNEL_HEADER" => Some(Self::BadChannelHeader),
            "BAD_RESPONSE_PAYLOAD" => Some(Self::BadResponsePayload),
            "BAD_RWSET" => Some(Self::BadRwset),
            "ILLEGAL_WRITESET" => Some(Self::IllegalWriteset),
            "INVALID_WRITESET" => Some(Self::InvalidWriteset),
            "INVALID_CHAINCODE" => Some(Self::InvalidChaincode),
            "NOT_VALIDATED" => Some(Self::NotValidated),
            "INVALID_OTHER_REASON" => Some(Self::InvalidOtherReason),
            _ => None,
        }
    }
}
/// Reserved entries in the key-level metadata map
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetaDataKeys {
    ValidationParameter = 0,
    ValidationParameterV2 = 1,
}
impl MetaDataKeys {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ValidationParameter => "VALIDATION_PARAMETER",
            Self::ValidationParameterV2 => "VALIDATION_PARAMETER_V2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALIDATION_PARAMETER" => Some(Self::ValidationParameter),
            "VALIDATION_PARAMETER_V2" => Some(Self::ValidationParameterV2),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChaincodeMessage {
    #[prost(enumeration = "chaincode_message::Type", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bytes = "vec", tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub proposal: ::core::option::Option<SignedProposal>,
    /// event emitted by chaincode. Used only with Init or Invoke.
    /// This event is then stored (currently)
    /// with Block.NonHashData.TransactionResult
    #[prost(message, optional, tag = "6")]
    pub chaincode_event: ::core::option::Option<ChaincodeEvent>,
    /// channel id
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ChaincodeMessage`.
pub mod chaincode_message {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Undefined = 0,
        Register = 1,
        Registered = 2,
        Init = 3,
        Ready = 4,
        Transaction = 5,
        Completed = 6,
        Error = 7,
        GetState = 8,
        PutState = 9,
        DelState = 10,
        InvokeChaincode = 11,
        Response = 13,
        GetStateByRange = 14,
        GetQueryResult = 15,
        QueryStateNext = 16,
        QueryStateClose = 17,
        Keepalive = 18,
        GetHistoryForKey = 19,
        GetStateMetadata = 20,
        PutStateMetadata = 21,
        GetPrivateDataHash = 22,
        PurgePrivateData = 23,
        WriteBatchState = 24,
        GetStateMultiple = 25,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::Register => "REGISTER",
                Self::Registered => "REGISTERED",
                Self::Init => "INIT",
                Self::Ready => "READY",
                Self::Transaction => "TRANSACTION",
                Self::Completed => "COMPLETED",
                Self::Error => "ERROR",
                Self::GetState => "GET_STATE",
                Self::PutState => "PUT_STATE",
                Self::DelState => "DEL_STATE",
                Self::InvokeChaincode => "INVOKE_CHAINCODE",
                Self::Response => "RESPONSE",
                Self::GetStateByRange => "GET_STATE_BY_RANGE",
                Self::GetQueryResult => "GET_QUERY_RESULT",
                Self::QueryStateNext => "QUERY_STATE_NEXT",
                Self::QueryStateClose => "QUERY_STATE_CLOSE",
                Self::Keepalive => "KEEPALIVE",
                Self::GetHistoryForKey => "GET_HISTORY_FOR_KEY",
                Self::GetStateMetadata => "GET_STATE_METADATA",
                Self::PutStateMetadata => "PUT_STATE_METADATA",
                Self::GetPrivateDataHash => "GET_PRIVATE_DATA_HASH",
                Self::PurgePrivateData => "PURGE_PRIVATE_DATA",
                Self::WriteBatchState => "WRITE_BATCH_STATE",
                Self::GetStateMultiple => "GET_STATE_MULTIPLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "REGISTER" => Some(Self::Register),
                "REGISTERED" => Some(Self::Registered),
                "INIT" => Some(Self::Init),
                "READY" => Some(Self::Ready),
                "TRANSACTION" => Some(Self::Transaction),
                "COMPLETED" => Some(Self::Completed),
                "ERROR" => Some(Self::Error),
                "GET_STATE" => Some(Self::GetState),
                "PUT_STATE" => Some(Self::PutState),
                "DEL_STATE" => Some(Self::DelState),
                "INVOKE_CHAINCODE" => Some(Self::InvokeChaincode),
                "RESPONSE" => Some(Self::Response),
                "GET_STATE_BY_RANGE" => Some(Self::GetStateByRange),
                "GET_QUERY_RESULT" => Some(Self::GetQueryResult),
                "QUERY_STATE_NEXT" => Some(Self::QueryStateNext),
                "QUERY_STATE_CLOSE" => Some(Self::QueryStateClose),
                "KEEPALIVE" => Some(Self::Keepalive),
                "GET_HISTORY_FOR_KEY" => Some(Self::GetHistoryForKey),
                "GET_STATE_METADATA" => Some(Self::GetStateMetadata),
                "PUT_STATE_METADATA" => Some(Self::PutStateMetadata),
                "GET_PRIVATE_DATA_HASH" => Some(Self::GetPrivateDataHash),
                "PURGE_PRIVATE_DATA" => Some(Self::PurgePrivateData),
                "WRITE_BATCH_STATE" => Some(Self::WriteBatchState),
                "GET_STATE_MULTIPLE" => Some(Self::GetStateMultiple),
                _ => None,
            }
        }
    }
}
/// GetState is the payload of a ChaincodeMessage. It contains a key which
/// is to be fetched from the ledger. If the collection is specified, the key
/// would be fetched from the collection (i.e., private state)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetState {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetStateMetadata {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
/// GetStateMultiple is the payload of the ChaincodeMessage.
/// It contains the keys to be retrieved from the ledger.
/// If a collection is specified, the keys will be retrieved
/// from the collection (i.e., the private state).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetStateMultiple {
    #[prost(string, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
/// GetStateMultipleResult is result of executing the GetStateMiltiple request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetStateMultipleResult {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// PutState is the payload of a ChaincodeMessage. It contains a key and value
/// which needs to be written to the transaction's write set. If the collection is
/// specified, the key and value would be written to the transaction's private
/// write set.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PutState {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PutStateMetadata {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<StateMetadata>,
}
/// WriteBatchState - set of records for state changes sent by the batch
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteBatchState {
    #[prost(message, repeated, tag = "1")]
    pub rec: ::prost::alloc::vec::Vec<WriteRecord>,
}
/// WriteRecord - single record with changes in the state of different types.
/// Filled in depending on the type.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WriteRecord {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<StateMetadata>,
    #[prost(enumeration = "write_record::Type", tag = "5")]
    pub r#type: i32,
}
/// Nested message and enum types in `WriteRecord`.
pub mod write_record {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Undefined = 0,
        PutState = 9,
        DelState = 10,
        PutStateMetadata = 21,
        PurgePrivateData = 23,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::PutState => "PUT_STATE",
                Self::DelState => "DEL_STATE",
                Self::PutStateMetadata => "PUT_STATE_METADATA",
                Self::PurgePrivateData => "PURGE_PRIVATE_DATA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "PUT_STATE" => Some(Self::PutState),
                "DEL_STATE" => Some(Self::DelState),
                "PUT_STATE_METADATA" => Some(Self::PutStateMetadata),
                "PURGE_PRIVATE_DATA" => Some(Self::PurgePrivateData),
                _ => None,
            }
        }
    }
}
/// DelState is the payload of a ChaincodeMessage. It contains a key which
/// needs to be recorded in the transaction's write set as a delete operation.
/// If the collection is specified, the key needs to be recorded in the
/// transaction's private write set as a delete operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DelState {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgePrivateState {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
/// GetStateByRange is the payload of a ChaincodeMessage. It contains a start key and
/// a end key required to execute range query. If the collection is specified,
/// the range query needs to be executed on the private data. The metadata hold
/// the byte representation of QueryMetadata.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetStateByRange {
    #[prost(string, tag = "1")]
    pub start_key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub end_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
/// GetQueryResult is the payload of a ChaincodeMessage. It contains a query
/// string in the form that is supported by the underlying state database.
/// If the collection is specified, the query needs to be executed on the
/// private data.  The metadata hold the byte representation of QueryMetadata.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetQueryResult {
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
/// QueryMetadata is the metadata of a GetStateByRange and GetQueryResult.
/// It contains a pageSize which denotes the number of records to be fetched
/// and a bookmark.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryMetadata {
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    #[prost(string, tag = "2")]
    pub bookmark: ::prost::alloc::string::String,
}
/// GetHistoryForKey is the payload of a ChaincodeMessage. It contains a key
/// for which the historical values need to be retrieved.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetHistoryForKey {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryStateNext {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryStateClose {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// QueryResultBytes hold the byte representation of a record returned by the peer.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryResultBytes {
    #[prost(bytes = "vec", tag = "1")]
    pub result_bytes: ::prost::alloc::vec::Vec<u8>,
}
/// QueryResponse is returned by the peer as a result of a GetStateByRange,
/// GetQueryResult, and GetHistoryForKey. It holds a bunch of records in
/// results field, a flag to denote whether more results need to be fetched from
/// the peer in has_more field, transaction id in id field, and a QueryResponseMetadata
/// in metadata field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<QueryResultBytes>,
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
/// QueryResponseMetadata is the metadata of a QueryResponse. It contains a count
/// which denotes the number of records fetched from the ledger and a bookmark.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryResponseMetadata {
    #[prost(int32, tag = "1")]
    pub fetched_records_count: i32,
    #[prost(string, tag = "2")]
    pub bookmark: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StateMetadata {
    #[prost(string, tag = "1")]
    pub metakey: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateMetadataResult {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<StateMetadata>,
}
/// Generated client implementations.
pub mod chaincode_support_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Interface that provides support to chaincode execution. ChaincodeContext
    /// provides the context necessary for the server to respond appropriately.
    #[derive(Debug, Clone)]
    pub struct ChaincodeSupportClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ChaincodeSupportClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ChaincodeSupportClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ChaincodeSupportClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn register(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ChaincodeMessage>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ChaincodeMessage>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/protos.ChaincodeSupport/Register",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.ChaincodeSupport", "Register"));
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod chaincode_support_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ChaincodeSupportServer.
    #[async_trait]
    pub trait ChaincodeSupport: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the Register method.
        type RegisterStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ChaincodeMessage, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn register(
            &self,
            request: tonic::Request<tonic::Streaming<super::ChaincodeMessage>>,
        ) -> std::result::Result<tonic::Response<Self::RegisterStream>, tonic::Status>;
    }
    /// Interface that provides support to chaincode execution. ChaincodeContext
    /// provides the context necessary for the server to respond appropriately.
    #[derive(Debug)]
    pub struct ChaincodeSupportServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ChaincodeSupportServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ChaincodeSupportServer<T>
    where
        T: ChaincodeSupport,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/protos.ChaincodeSupport/Register" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterSvc<T: ChaincodeSupport>(pub Arc<T>);
                    impl<
                        T: ChaincodeSupport,
                    > tonic::server::StreamingService<super::ChaincodeMessage>
                    for RegisterSvc<T> {
                        type Response = super::ChaincodeMessage;
                        type ResponseStream = T::RegisterStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::ChaincodeMessage>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ChaincodeSupport>::register(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ChaincodeSupportServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "protos.ChaincodeSupport";
    impl<T> tonic::server::NamedService for ChaincodeSupportServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod chaincode_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Chaincode as a server - peer establishes a connection to the chaincode as a client
    /// Currently only supports a stream connection.
    #[derive(Debug, Clone)]
    pub struct ChaincodeClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ChaincodeClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ChaincodeClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ChaincodeClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn connect(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ChaincodeMessage>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ChaincodeMessage>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Chaincode/Connect");
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new("protos.Chaincode", "Connect"));
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod chaincode_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ChaincodeServer.
    #[async_trait]
    pub trait Chaincode: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the Connect method.
        type ConnectStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ChaincodeMessage, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn connect(
            &self,
            request: tonic::Request<tonic::Streaming<super::ChaincodeMessage>>,
        ) -> std::result::Result<tonic::Response<Self::ConnectStream>, tonic::Status>;
    }
    /// Chaincode as a server - peer establishes a connection to the chaincode as a client
    /// Currently only supports a stream connection.
    #[derive(Debug)]
    pub struct ChaincodeServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ChaincodeServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ChaincodeServer<T>
    where
        T: Chaincode,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/protos.Chaincode/Connect" => {
                    #[allow(non_camel_case_types)]
                    struct ConnectSvc<T: Chaincode>(pub Arc<T>);
                    impl<
                        T: Chaincode,
                    > tonic::server::StreamingService<super::ChaincodeMessage>
                    for ConnectSvc<T> {
                        type Response = super::ChaincodeMessage;
                        type ResponseStream = T::ConnectStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::ChaincodeMessage>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Chaincode>::connect(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConnectSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ChaincodeServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "protos.Chaincode";
    impl<T> tonic::server::NamedService for ChaincodeServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
