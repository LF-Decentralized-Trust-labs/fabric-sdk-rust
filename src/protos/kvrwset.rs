// This file is @generated by prost-build.
/// KVRWSet encapsulates the read-write set for a chaincode that operates upon a KV or Document data model
/// This structure is used for both the public data and the private data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvrwSet {
    #[prost(message, repeated, tag = "1")]
    pub reads: ::prost::alloc::vec::Vec<KvRead>,
    #[prost(message, repeated, tag = "2")]
    pub range_queries_info: ::prost::alloc::vec::Vec<RangeQueryInfo>,
    #[prost(message, repeated, tag = "3")]
    pub writes: ::prost::alloc::vec::Vec<KvWrite>,
    #[prost(message, repeated, tag = "4")]
    pub metadata_writes: ::prost::alloc::vec::Vec<KvMetadataWrite>,
}
/// HashedRWSet encapsulates hashed representation of a private read-write set for KV or Document data model
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HashedRwSet {
    #[prost(message, repeated, tag = "1")]
    pub hashed_reads: ::prost::alloc::vec::Vec<KvReadHash>,
    #[prost(message, repeated, tag = "2")]
    pub hashed_writes: ::prost::alloc::vec::Vec<KvWriteHash>,
    #[prost(message, repeated, tag = "3")]
    pub metadata_writes: ::prost::alloc::vec::Vec<KvMetadataWriteHash>,
}
/// KVRead captures a read operation performed during transaction simulation
/// A 'nil' version indicates a non-existing key read by the transaction
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvRead {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub version: ::core::option::Option<Version>,
}
/// KVWrite captures a write (update/delete) operation performed during transaction simulation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvWrite {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_delete: bool,
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// KVMetadataWrite captures all the entries in the metadata associated with a key
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvMetadataWrite {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<KvMetadataEntry>,
}
/// KVReadHash is similar to the KVRead in spirit. However, it captures the hash of the key instead of the key itself
/// version is kept as is for now. However, if the version also needs to be privacy-protected, it would need to be the
/// hash of the version and hence of 'bytes' type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvReadHash {
    #[prost(bytes = "vec", tag = "1")]
    pub key_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub version: ::core::option::Option<Version>,
}
/// KVWriteHash is similar to the KVWrite. It captures a write (update/delete) operation performed during transaction simulation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvWriteHash {
    #[prost(bytes = "vec", tag = "1")]
    pub key_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub is_delete: bool,
    #[prost(bytes = "vec", tag = "3")]
    pub value_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "4")]
    pub is_purge: bool,
}
/// KVMetadataWriteHash captures all the upserts to the metadata associated with a key hash
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvMetadataWriteHash {
    #[prost(bytes = "vec", tag = "1")]
    pub key_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<KvMetadataEntry>,
}
/// KVMetadataEntry captures a 'name'ed entry in the metadata of a key/key-hash.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KvMetadataEntry {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Version encapsulates the version of a Key
/// A version of a committed key is maintained as the height of the transaction that committed the key.
/// The height is represenetd as a tuple <blockNum, txNum> where the txNum is the position of the transaction
/// (starting with 0) within block
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Version {
    #[prost(uint64, tag = "1")]
    pub block_num: u64,
    #[prost(uint64, tag = "2")]
    pub tx_num: u64,
}
/// RangeQueryInfo encapsulates the details of a range query performed by a transaction during simulation.
/// This helps protect transactions from phantom reads by varifying during validation whether any new items
/// got committed within the given range between transaction simuation and validation
/// (in addition to regular checks for updates/deletes of the existing items).
/// readInfo field contains either the KVReads (for the items read by the range query) or a merkle-tree hash
/// if the KVReads exceeds a pre-configured numbers
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeQueryInfo {
    #[prost(string, tag = "1")]
    pub start_key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub end_key: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub itr_exhausted: bool,
    #[prost(oneof = "range_query_info::ReadsInfo", tags = "4, 5")]
    pub reads_info: ::core::option::Option<range_query_info::ReadsInfo>,
}
/// Nested message and enum types in `RangeQueryInfo`.
pub mod range_query_info {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ReadsInfo {
        #[prost(message, tag = "4")]
        RawReads(super::QueryReads),
        #[prost(message, tag = "5")]
        ReadsMerkleHashes(super::QueryReadsMerkleSummary),
    }
}
/// QueryReads encapsulates the KVReads for the items read by a transaction as a result of a query execution
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryReads {
    #[prost(message, repeated, tag = "1")]
    pub kv_reads: ::prost::alloc::vec::Vec<KvRead>,
}
/// QueryReadsMerkleSummary encapsulates the Merkle-tree hashes for the QueryReads
/// This allows to reduce the size of RWSet in the presence of query results
/// by storing certain hashes instead of actual results.
/// maxDegree field refers to the maximum number of children in the tree at any level
/// maxLevel field contains the lowest level which has lesser nodes than maxDegree (starting from leaf level)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryReadsMerkleSummary {
    #[prost(uint32, tag = "1")]
    pub max_degree: u32,
    #[prost(uint32, tag = "2")]
    pub max_level: u32,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub max_level_hashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
