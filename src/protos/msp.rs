// This file is @generated by prost-build.
/// MSPConfig collects all the configuration information for
/// an MSP. The Config field should be unmarshalled in a way
/// that depends on the Type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MspConfig {
    /// Type holds the type of the MSP; the default one would
    /// be of type FABRIC implementing an X.509 based provider
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    /// Config is MSP dependent configuration info
    #[prost(bytes = "vec", tag = "2")]
    pub config: ::prost::alloc::vec::Vec<u8>,
}
/// FabricMSPConfig collects all the configuration information for
/// a Fabric MSP.
/// Here we assume a default certificate validation policy, where
/// any certificate signed by any of the listed rootCA certs would
/// be considered as valid under this MSP.
/// This MSP may or may not come with a signing identity. If it does,
/// it can also issue signing identities. If it does not, it can only
/// be used to validate and verify certificates.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FabricMspConfig {
    /// Name holds the identifier of the MSP; MSP identifier
    /// is chosen by the application that governs this MSP.
    /// For example, and assuming the default implementation of MSP,
    /// that is X.509-based and considers a single Issuer,
    /// this can refer to the Subject OU field or the Issuer OU field.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// List of root certificates trusted by this MSP
    /// they are used upon certificate validation (see
    /// comment for IntermediateCerts below)
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub root_certs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// List of intermediate certificates trusted by this MSP;
    /// they are used upon certificate validation as follows:
    /// validation attempts to build a path from the certificate
    /// to be validated (which is at one end of the path) and
    /// one of the certs in the RootCerts field (which is at
    /// the other end of the path). If the path is longer than
    /// 2, certificates in the middle are searched within the
    /// IntermediateCerts pool
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub intermediate_certs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Identity denoting the administrator of this MSP
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub admins: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Identity revocation list
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub revocation_list: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// SigningIdentity holds information on the signing identity
    /// this peer is to use, and which is to be imported by the
    /// MSP defined before
    #[prost(message, optional, tag = "6")]
    pub signing_identity: ::core::option::Option<SigningIdentityInfo>,
    /// OrganizationalUnitIdentifiers holds one or more
    /// fabric organizational unit identifiers that belong to
    /// this MSP configuration
    #[prost(message, repeated, tag = "7")]
    pub organizational_unit_identifiers: ::prost::alloc::vec::Vec<FabricOuIdentifier>,
    /// FabricCryptoConfig contains the configuration parameters
    /// for the cryptographic algorithms used by this MSP
    #[prost(message, optional, tag = "8")]
    pub crypto_config: ::core::option::Option<FabricCryptoConfig>,
    /// List of TLS root certificates trusted by this MSP.
    /// They are returned by GetTLSRootCerts.
    #[prost(bytes = "vec", repeated, tag = "9")]
    pub tls_root_certs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// List of TLS intermediate certificates trusted by this MSP;
    /// They are returned by GetTLSIntermediateCerts.
    #[prost(bytes = "vec", repeated, tag = "10")]
    pub tls_intermediate_certs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// fabric_node_ous contains the configuration to distinguish clients from peers from orderers
    /// based on the OUs.
    #[prost(message, optional, tag = "11")]
    pub fabric_node_ous: ::core::option::Option<FabricNodeOUs>,
}
/// FabricCryptoConfig contains configuration parameters
/// for the cryptographic algorithms used by the MSP
/// this configuration refers to
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FabricCryptoConfig {
    /// SignatureHashFamily is a string representing the hash family to be used
    /// during sign and verify operations.
    /// Allowed values are "SHA2" and "SHA3".
    #[prost(string, tag = "1")]
    pub signature_hash_family: ::prost::alloc::string::String,
    /// IdentityIdentifierHashFunction is a string representing the hash function
    /// to be used during the computation of the identity identifier of an MSP identity.
    /// Allowed values are "SHA256", "SHA384" and "SHA3_256", "SHA3_384".
    #[prost(string, tag = "2")]
    pub identity_identifier_hash_function: ::prost::alloc::string::String,
}
/// IdemixMSPConfig collects all the configuration information for
/// an Idemix MSP.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdemixMspConfig {
    /// Name holds the identifier of the MSP
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// ipk represents the (serialized) issuer public key
    #[prost(bytes = "vec", tag = "2")]
    pub ipk: ::prost::alloc::vec::Vec<u8>,
    /// signer may contain crypto material to configure a default signer
    #[prost(message, optional, tag = "3")]
    pub signer: ::core::option::Option<IdemixMspSignerConfig>,
    /// revocation_pk is the public key used for revocation of credentials
    #[prost(bytes = "vec", tag = "4")]
    pub revocation_pk: ::prost::alloc::vec::Vec<u8>,
    /// epoch represents the current epoch (time interval) used for revocation
    #[prost(int64, tag = "5")]
    pub epoch: i64,
}
/// IdemixMSPSIgnerConfig contains the crypto material to set up an idemix signing identity
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdemixMspSignerConfig {
    /// cred represents the serialized idemix credential of the default signer
    #[prost(bytes = "vec", tag = "1")]
    pub cred: ::prost::alloc::vec::Vec<u8>,
    /// sk is the secret key of the default signer, corresponding to credential Cred
    #[prost(bytes = "vec", tag = "2")]
    pub sk: ::prost::alloc::vec::Vec<u8>,
    /// organizational_unit_identifier defines the organizational unit the default signer is in
    #[prost(string, tag = "3")]
    pub organizational_unit_identifier: ::prost::alloc::string::String,
    /// role defines whether the default signer is admin, peer, member or client
    #[prost(int32, tag = "4")]
    pub role: i32,
    /// enrollment_id contains the enrollment id of this signer
    #[prost(string, tag = "5")]
    pub enrollment_id: ::prost::alloc::string::String,
    /// credential_revocation_information contains a serialized CredentialRevocationInformation
    #[prost(bytes = "vec", tag = "6")]
    pub credential_revocation_information: ::prost::alloc::vec::Vec<u8>,
}
/// SigningIdentityInfo represents the configuration information
/// related to the signing identity the peer is to use for generating
/// endorsements
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SigningIdentityInfo {
    /// PublicSigner carries the public information of the signing
    /// identity. For an X.509 provider this would be represented by
    /// an X.509 certificate
    #[prost(bytes = "vec", tag = "1")]
    pub public_signer: ::prost::alloc::vec::Vec<u8>,
    /// PrivateSigner denotes a reference to the private key of the
    /// peer's signing identity
    #[prost(message, optional, tag = "2")]
    pub private_signer: ::core::option::Option<KeyInfo>,
}
/// KeyInfo represents a (secret) key that is either already stored
/// in the bccsp/keystore or key material to be imported to the
/// bccsp key-store. In later versions it may contain also a
/// keystore identifier
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyInfo {
    /// Identifier of the key inside the default keystore; this for
    /// the case of Software BCCSP as well as the HSM BCCSP would be
    /// the SKI of the key
    #[prost(string, tag = "1")]
    pub key_identifier: ::prost::alloc::string::String,
    /// KeyMaterial (optional) for the key to be imported; this is
    /// properly encoded key bytes, prefixed by the type of the key
    #[prost(bytes = "vec", tag = "2")]
    pub key_material: ::prost::alloc::vec::Vec<u8>,
}
/// FabricOUIdentifier represents an organizational unit and
/// its related chain of trust identifier.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FabricOuIdentifier {
    /// Certificate represents the second certificate in a certification chain.
    /// (Notice that the first certificate in a certification chain is supposed
    /// to be the certificate of an identity).
    /// It must correspond to the certificate of root or intermediate CA
    /// recognized by the MSP this message belongs to.
    /// Starting from this certificate, a certification chain is computed
    /// and bound to the OrganizationUnitIdentifier specified
    #[prost(bytes = "vec", tag = "1")]
    pub certificate: ::prost::alloc::vec::Vec<u8>,
    /// OrganizationUnitIdentifier defines the organizational unit under the
    /// MSP identified with MSPIdentifier
    #[prost(string, tag = "2")]
    pub organizational_unit_identifier: ::prost::alloc::string::String,
}
/// FabricNodeOUs contains configuration to tell apart clients from peers from orderers
/// based on OUs. If NodeOUs recognition is enabled then an msp identity
/// that does not contain any of the specified OU will be considered invalid.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FabricNodeOUs {
    /// If true then an msp identity that does not contain any of the specified OU will be considered invalid.
    #[prost(bool, tag = "1")]
    pub enable: bool,
    /// OU Identifier of the clients
    #[prost(message, optional, tag = "2")]
    pub client_ou_identifier: ::core::option::Option<FabricOuIdentifier>,
    /// OU Identifier of the peers
    #[prost(message, optional, tag = "3")]
    pub peer_ou_identifier: ::core::option::Option<FabricOuIdentifier>,
    /// OU Identifier of the admins
    #[prost(message, optional, tag = "4")]
    pub admin_ou_identifier: ::core::option::Option<FabricOuIdentifier>,
    /// OU Identifier of the orderers
    #[prost(message, optional, tag = "5")]
    pub orderer_ou_identifier: ::core::option::Option<FabricOuIdentifier>,
}
/// This struct represents an Identity
/// (with its MSP identifier) to be used
/// to serialize it and deserialize it
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SerializedIdentity {
    /// The identifier of the associated membership service provider
    #[prost(string, tag = "1")]
    pub mspid: ::prost::alloc::string::String,
    /// the Identity, serialized according to the rules of its MPS
    #[prost(bytes = "vec", tag = "2")]
    pub id_bytes: ::prost::alloc::vec::Vec<u8>,
}
/// This struct represents an Idemix Identity
/// to be used to serialize it and deserialize it.
/// The IdemixMSP will first serialize an idemix identity to bytes using
/// this proto, and then uses these bytes as id_bytes in SerializedIdentity
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SerializedIdemixIdentity {
    /// nym_x is the X-component of the pseudonym elliptic curve point.
    /// It is a \[\]byte representation of an amcl.BIG
    /// The pseudonym can be seen as a public key of the identity, it is used to verify signatures.
    #[prost(bytes = "vec", tag = "1")]
    pub nym_x: ::prost::alloc::vec::Vec<u8>,
    /// nym_y is the Y-component of the pseudonym elliptic curve point.
    /// It is a \[\]byte representation of an amcl.BIG
    /// The pseudonym can be seen as a public key of the identity, it is used to verify signatures.
    #[prost(bytes = "vec", tag = "2")]
    pub nym_y: ::prost::alloc::vec::Vec<u8>,
    /// ou contains the organizational unit of the idemix identity
    #[prost(bytes = "vec", tag = "3")]
    pub ou: ::prost::alloc::vec::Vec<u8>,
    /// role contains the role of this identity (e.g., ADMIN or MEMBER)
    #[prost(bytes = "vec", tag = "4")]
    pub role: ::prost::alloc::vec::Vec<u8>,
    /// proof contains the cryptographic evidence that this identity is valid
    #[prost(bytes = "vec", tag = "5")]
    pub proof: ::prost::alloc::vec::Vec<u8>,
}
