// This file is @generated by prost-build.
/// LastConfig is the encoded value for the Metadata message which is encoded in the LAST_CONFIGURATION block metadata index
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LastConfig {
    #[prost(uint64, tag = "1")]
    pub index: u64,
}
/// Metadata is a common structure to be used to encode block metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<MetadataSignature>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSignature {
    /// An encoded SignatureHeader
    #[prost(bytes = "vec", tag = "1")]
    pub signature_header: ::prost::alloc::vec::Vec<u8>,
    /// The signature over the concatenation of the Metadata value bytes, signatureHeader, and block header
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// An encoded IdentifierHeader. If the signature header is empty, this is used to identify the creator by id
    #[prost(bytes = "vec", tag = "3")]
    pub identifier_header: ::prost::alloc::vec::Vec<u8>,
}
/// IdentifierHeader is used as an alternative to a SignatureHeader when the creator can be referenced by id
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentifierHeader {
    /// A unique identifier that represents the creator of the message
    #[prost(uint32, tag = "1")]
    pub identifier: u32,
    /// Arbitrary number that may only be used once. Can be used to detect replay attacks.
    #[prost(bytes = "vec", tag = "2")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    #[prost(bytes = "vec", tag = "1")]
    pub channel_header: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub signature_header: ::prost::alloc::vec::Vec<u8>,
}
/// Header is a generic replay prevention and identity message to include in a signed payload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelHeader {
    /// Header types 0-10000 are reserved and defined by HeaderType
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    /// Version indicates message protocol version
    #[prost(int32, tag = "2")]
    pub version: i32,
    /// Timestamp is the local time when the message was created
    /// by the sender
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Identifier of the channel this message is bound for
    #[prost(string, tag = "4")]
    pub channel_id: ::prost::alloc::string::String,
    /// An unique identifier that is used end-to-end.
    ///   -  set by higher layers such as end user or SDK
    ///   -  passed to the endorser (which will check for uniqueness)
    ///   -  as the header is passed along unchanged, it will be
    ///      be retrieved by the committer (uniqueness check here as well)
    ///   -  to be stored in the ledger
    #[prost(string, tag = "5")]
    pub tx_id: ::prost::alloc::string::String,
    /// The epoch in which this header was generated, where epoch is defined based on block height
    /// Epoch in which the response has been generated. This field identifies a
    /// logical window of time. A proposal response is accepted by a peer only if
    /// two conditions hold:
    /// 1. the epoch specified in the message is the current epoch
    /// 2. this message has been only seen once during this epoch (i.e. it hasn't
    ///     been replayed)
    #[prost(uint64, tag = "6")]
    pub epoch: u64,
    /// Extension that may be attached based on the header type
    #[prost(bytes = "vec", tag = "7")]
    pub extension: ::prost::alloc::vec::Vec<u8>,
    /// If mutual TLS is employed, this represents
    /// the hash of the client's TLS certificate
    #[prost(bytes = "vec", tag = "8")]
    pub tls_cert_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureHeader {
    /// Creator of the message, a marshaled msp.SerializedIdentity
    #[prost(bytes = "vec", tag = "1")]
    pub creator: ::prost::alloc::vec::Vec<u8>,
    /// Arbitrary number that may only be used once. Can be used to detect replay attacks.
    #[prost(bytes = "vec", tag = "2")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
}
/// Payload is the message contents (and header to allow for signing)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    /// Header is included to provide identity and prevent replay
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<Header>,
    /// Data, the encoding of which is defined by the type in the header
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Envelope wraps a Payload with a signature so that the message may be authenticated
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Envelope {
    /// A marshaled Payload
    #[prost(bytes = "vec", tag = "1")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// A signature by the creator specified in the Payload header
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// This is finalized block structure to be shared among the orderer and peer
/// Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
/// in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
/// the Metadata is not.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<BlockData>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<BlockMetadata>,
}
/// BlockHeader is the element of the block which forms the block chain
/// The block header is hashed using the configured chain hashing algorithm
/// over the ASN.1 encoding of the BlockHeader
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    /// The position in the blockchain
    #[prost(uint64, tag = "1")]
    pub number: u64,
    /// The hash of the previous block header
    #[prost(bytes = "vec", tag = "2")]
    pub previous_hash: ::prost::alloc::vec::Vec<u8>,
    /// The hash of the BlockData, by MerkleTree
    #[prost(bytes = "vec", tag = "3")]
    pub data_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockData {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockMetadata {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub metadata: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// OrdererBlockMetadata defines metadata that is set by the ordering service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrdererBlockMetadata {
    #[prost(message, optional, tag = "1")]
    pub last_config: ::core::option::Option<LastConfig>,
    #[prost(bytes = "vec", tag = "2")]
    pub consenter_metadata: ::prost::alloc::vec::Vec<u8>,
}
/// These status codes are intended to resemble selected HTTP status codes
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
    Unknown = 0,
    Success = 200,
    BadRequest = 400,
    Forbidden = 403,
    NotFound = 404,
    RequestEntityTooLarge = 413,
    InternalServerError = 500,
    NotImplemented = 501,
    ServiceUnavailable = 503,
}
impl Status {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::Success => "SUCCESS",
            Self::BadRequest => "BAD_REQUEST",
            Self::Forbidden => "FORBIDDEN",
            Self::NotFound => "NOT_FOUND",
            Self::RequestEntityTooLarge => "REQUEST_ENTITY_TOO_LARGE",
            Self::InternalServerError => "INTERNAL_SERVER_ERROR",
            Self::NotImplemented => "NOT_IMPLEMENTED",
            Self::ServiceUnavailable => "SERVICE_UNAVAILABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "SUCCESS" => Some(Self::Success),
            "BAD_REQUEST" => Some(Self::BadRequest),
            "FORBIDDEN" => Some(Self::Forbidden),
            "NOT_FOUND" => Some(Self::NotFound),
            "REQUEST_ENTITY_TOO_LARGE" => Some(Self::RequestEntityTooLarge),
            "INTERNAL_SERVER_ERROR" => Some(Self::InternalServerError),
            "NOT_IMPLEMENTED" => Some(Self::NotImplemented),
            "SERVICE_UNAVAILABLE" => Some(Self::ServiceUnavailable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HeaderType {
    /// Used for messages which are signed but opaque
    Message = 0,
    /// Used for messages which express the channel config
    Config = 1,
    /// Used for transactions which update the channel config
    ConfigUpdate = 2,
    /// Used by the SDK to submit endorser based transactions
    EndorserTransaction = 3,
    /// Was used internally by the orderer for management, no longer used since system channel was removed
    OrdererTransaction = 4,
    /// Used as the type for Envelope messages submitted to instruct the Deliver API to seek
    DeliverSeekInfo = 5,
    /// Used for packaging chaincode artifacts for install
    ChaincodePackage = 6,
}
impl HeaderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Message => "MESSAGE",
            Self::Config => "CONFIG",
            Self::ConfigUpdate => "CONFIG_UPDATE",
            Self::EndorserTransaction => "ENDORSER_TRANSACTION",
            Self::OrdererTransaction => "ORDERER_TRANSACTION",
            Self::DeliverSeekInfo => "DELIVER_SEEK_INFO",
            Self::ChaincodePackage => "CHAINCODE_PACKAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE" => Some(Self::Message),
            "CONFIG" => Some(Self::Config),
            "CONFIG_UPDATE" => Some(Self::ConfigUpdate),
            "ENDORSER_TRANSACTION" => Some(Self::EndorserTransaction),
            "ORDERER_TRANSACTION" => Some(Self::OrdererTransaction),
            "DELIVER_SEEK_INFO" => Some(Self::DeliverSeekInfo),
            "CHAINCODE_PACKAGE" => Some(Self::ChaincodePackage),
            _ => None,
        }
    }
}
/// This enum enlists indexes of the block metadata array
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlockMetadataIndex {
    /// Block metadata array position for block signatures
    Signatures = 0,
    /// Block metadata array position to store last configuration block sequence number
    LastConfig = 1,
    /// Block metadata array position to store serialized bit array filter of invalid transactions
    TransactionsFilter = 2,
    /// Block metadata array position to store operational metadata for orderers
    Orderer = 3,
    /// Block metadata array position to store the hash of TRANSACTIONS_FILTER, State Updates,
    /// and the COMMIT_HASH of the previous block
    CommitHash = 4,
}
impl BlockMetadataIndex {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Signatures => "SIGNATURES",
            Self::LastConfig => "LAST_CONFIG",
            Self::TransactionsFilter => "TRANSACTIONS_FILTER",
            Self::Orderer => "ORDERER",
            Self::CommitHash => "COMMIT_HASH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNATURES" => Some(Self::Signatures),
            "LAST_CONFIG" => Some(Self::LastConfig),
            "TRANSACTIONS_FILTER" => Some(Self::TransactionsFilter),
            "ORDERER" => Some(Self::Orderer),
            "COMMIT_HASH" => Some(Self::CommitHash),
            _ => None,
        }
    }
}
/// MSPPrincipal aims to represent an MSP-centric set of identities.
/// In particular, this structure allows for definition of
///   - a group of identities that are member of the same MSP
///   - a group of identities that are member of the same organization unit
///     in the same MSP
///   - a group of identities that are administering a specific MSP
///   - a specific identity
/// Expressing these groups is done given two fields of the fields below
///   - Classification, that defines the type of classification of identities
///     in an MSP this principal would be defined on; Classification can take
///     three values:
///      (i)  ByMSPRole: that represents a classification of identities within
///           MSP based on one of the two pre-defined MSP rules, "member" and "admin"
///      (ii) ByOrganizationUnit: that represents a classification of identities
///           within MSP based on the organization unit an identity belongs to
///      (iii)ByIdentity that denotes that MSPPrincipal is mapped to a single
///           identity/certificate; this would mean that the Principal bytes
///           message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MspPrincipal {
    /// Classification describes the way that one should process
    /// Principal. An Classification value of "ByOrganizationUnit" reflects
    /// that "Principal" contains the name of an organization this MSP
    /// handles. A Classification value "ByIdentity" means that
    /// "Principal" contains a specific identity. Default value
    /// denotes that Principal contains one of the groups by
    /// default supported by all MSPs ("admin" or "member").
    #[prost(enumeration = "msp_principal::Classification", tag = "1")]
    pub principal_classification: i32,
    /// Principal completes the policy principal definition. For the default
    /// principal types, Principal can be either "Admin" or "Member".
    /// For the ByOrganizationUnit/ByIdentity values of Classification,
    /// PolicyPrincipal acquires its value from an organization unit or
    /// identity, respectively.
    /// For the Combined Classification type, the Principal is a marshalled
    /// CombinedPrincipal.
    #[prost(bytes = "vec", tag = "2")]
    pub principal: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `MSPPrincipal`.
pub mod msp_principal {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Classification {
        /// Represents the one of the dedicated MSP roles, the
        Role = 0,
        /// one of a member of MSP network, and the one of an
        /// administrator of an MSP network
        ///
        /// Denotes a finer grained (affiliation-based)
        OrganizationUnit = 1,
        /// groupping of entities, per MSP affiliation
        /// E.g., this can well be represented by an MSP's
        /// Organization unit
        ///
        /// Denotes a principal that consists of a single
        Identity = 2,
        /// identity
        ///
        /// Denotes a principal that can be used to enforce
        Anonymity = 3,
        /// an identity to be anonymous or nominal.
        ///
        /// Denotes a combined principal
        Combined = 4,
    }
    impl Classification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Role => "ROLE",
                Self::OrganizationUnit => "ORGANIZATION_UNIT",
                Self::Identity => "IDENTITY",
                Self::Anonymity => "ANONYMITY",
                Self::Combined => "COMBINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE" => Some(Self::Role),
                "ORGANIZATION_UNIT" => Some(Self::OrganizationUnit),
                "IDENTITY" => Some(Self::Identity),
                "ANONYMITY" => Some(Self::Anonymity),
                "COMBINED" => Some(Self::Combined),
                _ => None,
            }
        }
    }
}
/// OrganizationUnit governs the organization of the Principal
/// field of a policy principal when a specific organization unity members
/// are to be defined within a policy principal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrganizationUnit {
    /// MSPIdentifier represents the identifier of the MSP this organization unit
    /// refers to
    #[prost(string, tag = "1")]
    pub msp_identifier: ::prost::alloc::string::String,
    /// OrganizationUnitIdentifier defines the organizational unit under the
    /// MSP identified with MSPIdentifier
    #[prost(string, tag = "2")]
    pub organizational_unit_identifier: ::prost::alloc::string::String,
    /// CertifiersIdentifier is the hash of certificates chain of trust
    /// related to this organizational unit
    #[prost(bytes = "vec", tag = "3")]
    pub certifiers_identifier: ::prost::alloc::vec::Vec<u8>,
}
/// MSPRole governs the organization of the Principal
/// field of an MSPPrincipal when it aims to define one of the
/// two dedicated roles within an MSP: Admin and Members.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MspRole {
    /// MSPIdentifier represents the identifier of the MSP this principal
    /// refers to
    #[prost(string, tag = "1")]
    pub msp_identifier: ::prost::alloc::string::String,
    /// MSPRoleType defines which of the available, pre-defined MSP-roles
    /// an identiy should posess inside the MSP with identifier MSPidentifier
    #[prost(enumeration = "msp_role::MspRoleType", tag = "2")]
    pub role: i32,
}
/// Nested message and enum types in `MSPRole`.
pub mod msp_role {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MspRoleType {
        /// Represents an MSP Member
        Member = 0,
        /// Represents an MSP Admin
        Admin = 1,
        /// Represents an MSP Client
        Client = 2,
        /// Represents an MSP Peer
        Peer = 3,
        /// Represents an MSP Orderer
        Orderer = 4,
    }
    impl MspRoleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Member => "MEMBER",
                Self::Admin => "ADMIN",
                Self::Client => "CLIENT",
                Self::Peer => "PEER",
                Self::Orderer => "ORDERER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEMBER" => Some(Self::Member),
                "ADMIN" => Some(Self::Admin),
                "CLIENT" => Some(Self::Client),
                "PEER" => Some(Self::Peer),
                "ORDERER" => Some(Self::Orderer),
                _ => None,
            }
        }
    }
}
/// MSPIdentityAnonymity can be used to enforce an identity to be anonymous or nominal.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MspIdentityAnonymity {
    #[prost(enumeration = "msp_identity_anonymity::MspIdentityAnonymityType", tag = "1")]
    pub anonymity_type: i32,
}
/// Nested message and enum types in `MSPIdentityAnonymity`.
pub mod msp_identity_anonymity {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MspIdentityAnonymityType {
        /// Represents a nominal MSP Identity
        Nominal = 0,
        /// Represents an anonymous MSP Identity
        Anonymous = 1,
    }
    impl MspIdentityAnonymityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Nominal => "NOMINAL",
                Self::Anonymous => "ANONYMOUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOMINAL" => Some(Self::Nominal),
                "ANONYMOUS" => Some(Self::Anonymous),
                _ => None,
            }
        }
    }
}
/// CombinedPrincipal governs the organization of the Principal
/// field of a policy principal when principal_classification has
/// indicated that a combined form of principals is required
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CombinedPrincipal {
    /// Principals refer to combined principals
    #[prost(message, repeated, tag = "1")]
    pub principals: ::prost::alloc::vec::Vec<MspPrincipal>,
}
/// Policy expresses a policy which the orderer can evaluate, because there has been some desire expressed to support
/// multiple policy engines, this is typed as a oneof for now
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Policy {
    /// For outside implementors, consider the first 1000 types reserved, otherwise one of PolicyType
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `Policy`.
pub mod policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyType {
        /// Reserved to check for proper initialization
        Unknown = 0,
        Signature = 1,
        Msp = 2,
        ImplicitMeta = 3,
    }
    impl PolicyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Signature => "SIGNATURE",
                Self::Msp => "MSP",
                Self::ImplicitMeta => "IMPLICIT_META",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "SIGNATURE" => Some(Self::Signature),
                "MSP" => Some(Self::Msp),
                "IMPLICIT_META" => Some(Self::ImplicitMeta),
                _ => None,
            }
        }
    }
}
/// SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignaturePolicyEnvelope {
    #[prost(int32, tag = "1")]
    pub version: i32,
    #[prost(message, optional, tag = "2")]
    pub rule: ::core::option::Option<SignaturePolicy>,
    #[prost(message, repeated, tag = "3")]
    pub identities: ::prost::alloc::vec::Vec<MspPrincipal>,
}
/// SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
/// policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
/// to express AND as well as OR, as well as of course N out of the following M policies
/// SignedBy implies that the signature is from a valid certificate which is signed by the trusted
/// authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
/// and will be the CA for more traditional certificates
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignaturePolicy {
    #[prost(oneof = "signature_policy::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<signature_policy::Type>,
}
/// Nested message and enum types in `SignaturePolicy`.
pub mod signature_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NOutOf {
        #[prost(int32, tag = "1")]
        pub n: i32,
        #[prost(message, repeated, tag = "2")]
        pub rules: ::prost::alloc::vec::Vec<super::SignaturePolicy>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(int32, tag = "1")]
        SignedBy(i32),
        #[prost(message, tag = "2")]
        NOutOf(NOutOf),
    }
}
/// ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration
/// It is implicit because the rule is generate implicitly based on the number of sub policies
/// It is meta because it depends only on the result of other policies
/// When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy
/// of name sub_policy, evaluates the collection and applies the rule.
/// For example, with 4 sub-groups, and a policy name of "foo", ImplicitMetaPolicy retrieves
/// each sub-group, retrieves policy "foo" for each subgroup, evaluates it, and, in the case of ANY
/// 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImplicitMetaPolicy {
    #[prost(string, tag = "1")]
    pub sub_policy: ::prost::alloc::string::String,
    #[prost(enumeration = "implicit_meta_policy::Rule", tag = "2")]
    pub rule: i32,
}
/// Nested message and enum types in `ImplicitMetaPolicy`.
pub mod implicit_meta_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Rule {
        /// Requires any of the sub-policies be satisfied, if no sub-policies exist, always returns true
        Any = 0,
        /// Requires all of the sub-policies be satisfied
        All = 1,
        /// Requires a strict majority (greater than half) of the sub-policies be satisfied
        Majority = 2,
    }
    impl Rule {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Any => "ANY",
                Self::All => "ALL",
                Self::Majority => "MAJORITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANY" => Some(Self::Any),
                "ALL" => Some(Self::All),
                "MAJORITY" => Some(Self::Majority),
                _ => None,
            }
        }
    }
}
/// ApplicationPolicy captures the diffenrent policy types that
/// are set and evaluted at the application level.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationPolicy {
    #[prost(oneof = "application_policy::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<application_policy::Type>,
}
/// Nested message and enum types in `ApplicationPolicy`.
pub mod application_policy {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// SignaturePolicy type is used if the policy is specified as
        /// a combination (using threshold gates) of signatures from MSP
        /// principals
        #[prost(message, tag = "1")]
        SignaturePolicy(super::SignaturePolicyEnvelope),
        /// ChannelConfigPolicyReference is used when the policy is
        /// specified as a string that references a policy defined in
        /// the configuration of the channel
        #[prost(string, tag = "2")]
        ChannelConfigPolicyReference(::prost::alloc::string::String),
    }
}
/// ConfigEnvelope is designed to contain _all_ configuration for a chain with no dependency
/// on previous configuration transactions.
///
/// It is generated with the following scheme:
///    1. Retrieve the existing configuration
///    2. Note the config properties (ConfigValue, ConfigPolicy, ConfigGroup) to be modified
///    3. Add any intermediate ConfigGroups to the ConfigUpdate.read_set (sparsely)
///    4. Add any additional desired dependencies to ConfigUpdate.read_set (sparsely)
///    5. Modify the config properties, incrementing each version by 1, set them in the ConfigUpdate.write_set
///       Note: any element not modified but specified should already be in the read_set, so may be specified sparsely
///    6. Create ConfigUpdate message and marshal it into ConfigUpdateEnvelope.update and encode the required signatures
///      a) Each signature is of type ConfigSignature
///      b) The ConfigSignature signature is over the concatenation of signature_header and the ConfigUpdate bytes (which includes a ChainHeader)
///    5. Submit new Config for ordering in Envelope signed by submitter
///      a) The Envelope Payload has data set to the marshaled ConfigEnvelope
///      b) The Envelope Payload has a header of type Header.Type.CONFIG_UPDATE
///
/// The configuration manager will verify:
///    1. All items in the read_set exist at the read versions
///    2. All items in the write_set at a different version than, or not in, the read_set have been appropriately signed according to their mod_policy
///    3. The new configuration satisfies the ConfigSchema
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigEnvelope {
    /// A marshaled Config structure
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<Config>,
    /// The last CONFIG_UPDATE message which generated this current configuration
    #[prost(message, optional, tag = "2")]
    pub last_update: ::core::option::Option<Envelope>,
}
/// Config represents the config for a particular channel
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    #[prost(uint64, tag = "1")]
    pub sequence: u64,
    /// channel_group is a bad name for this, it should be changed to root when API breakage is allowed
    #[prost(message, optional, tag = "2")]
    pub channel_group: ::core::option::Option<ConfigGroup>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigUpdateEnvelope {
    /// A marshaled ConfigUpdate structure
    #[prost(bytes = "vec", tag = "1")]
    pub config_update: ::prost::alloc::vec::Vec<u8>,
    /// Signatures over the config_update
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<ConfigSignature>,
}
/// ConfigUpdate is used to submit a subset of config and to have the orderer apply to Config
/// it is always submitted inside a ConfigUpdateEnvelope which allows the addition of signatures
/// resulting in a new total configuration.  The update is applied as follows:
/// 1. The versions from all of the elements in the read_set is verified against the versions in the existing config.
///     If there is a mismatch in the read versions, then the config update fails and is rejected.
/// 2. Any elements in the write_set with the same version as the read_set are ignored.
/// 3. The corresponding mod_policy for every remaining element in the write_set is collected.
/// 4. Each policy is checked against the signatures from the ConfigUpdateEnvelope, any failing to verify are rejected
/// 5. The write_set is applied to the Config and the ConfigGroupSchema verifies that the updates were legal
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigUpdate {
    /// Which channel this config update is for
    #[prost(string, tag = "1")]
    pub channel_id: ::prost::alloc::string::String,
    /// ReadSet explicitly lists the portion of the config which was read, this should be sparse with only Version set
    #[prost(message, optional, tag = "2")]
    pub read_set: ::core::option::Option<ConfigGroup>,
    /// WriteSet lists the portion of the config which was written, this should included updated Versions
    #[prost(message, optional, tag = "3")]
    pub write_set: ::core::option::Option<ConfigGroup>,
    /// Data which is not to be reflected in the resulting Config, but is still needed for some other purpose.  For instance, rscc_seed_data
    #[prost(map = "string, bytes", tag = "5")]
    pub isolated_data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
/// ConfigGroup is the hierarchical data structure for holding config
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigGroup {
    #[prost(uint64, tag = "1")]
    pub version: u64,
    #[prost(map = "string, message", tag = "2")]
    pub groups: ::std::collections::HashMap<::prost::alloc::string::String, ConfigGroup>,
    #[prost(map = "string, message", tag = "3")]
    pub values: ::std::collections::HashMap<::prost::alloc::string::String, ConfigValue>,
    #[prost(map = "string, message", tag = "4")]
    pub policies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ConfigPolicy,
    >,
    #[prost(string, tag = "5")]
    pub mod_policy: ::prost::alloc::string::String,
}
/// ConfigValue represents an individual piece of config data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigValue {
    #[prost(uint64, tag = "1")]
    pub version: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub mod_policy: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigPolicy {
    #[prost(uint64, tag = "1")]
    pub version: u64,
    #[prost(message, optional, tag = "2")]
    pub policy: ::core::option::Option<Policy>,
    #[prost(string, tag = "3")]
    pub mod_policy: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigSignature {
    /// A marshaled SignatureHeader
    #[prost(bytes = "vec", tag = "1")]
    pub signature_header: ::prost::alloc::vec::Vec<u8>,
    /// Signature over the concatenation signatureHeader bytes and config bytes
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// CollectionConfigPackage represents an array of CollectionConfig
/// messages; the extra struct is required because repeated oneof is
/// forbidden by the protobuf syntax
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionConfigPackage {
    #[prost(message, repeated, tag = "1")]
    pub config: ::prost::alloc::vec::Vec<CollectionConfig>,
}
/// CollectionConfig defines the configuration of a collection object;
/// it currently contains a single, static type.
/// Dynamic collections are deferred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionConfig {
    #[prost(oneof = "collection_config::Payload", tags = "1")]
    pub payload: ::core::option::Option<collection_config::Payload>,
}
/// Nested message and enum types in `CollectionConfig`.
pub mod collection_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        StaticCollectionConfig(super::StaticCollectionConfig),
    }
}
/// StaticCollectionConfig constitutes the configuration parameters of a
/// static collection object. Static collections are collections that are
/// known at chaincode instantiation time, and that cannot be changed.
/// Dynamic collections are deferred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticCollectionConfig {
    /// the name of the collection inside the denoted chaincode
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// a reference to a policy residing / managed in the config block
    /// to define which orgs have access to this collection’s private data
    #[prost(message, optional, tag = "2")]
    pub member_orgs_policy: ::core::option::Option<CollectionPolicyConfig>,
    /// The minimum number of peers private data will be sent to upon
    /// endorsement. The endorsement would fail if dissemination to at least
    /// this number of peers is not achieved.
    #[prost(int32, tag = "3")]
    pub required_peer_count: i32,
    /// The maximum number of peers that private data will be sent to
    /// upon endorsement. This number has to be bigger than required_peer_count.
    #[prost(int32, tag = "4")]
    pub maximum_peer_count: i32,
    /// The number of blocks after which the collection data expires.
    /// For instance if the value is set to 10, a key last modified by block number 100
    /// will be purged at block number 111. A zero value is treated same as MaxUint64
    #[prost(uint64, tag = "5")]
    pub block_to_live: u64,
    /// The member only read access denotes whether only collection member clients
    /// can read the private data (if set to true), or even non members can
    /// read the data (if set to false, for example if you want to implement more granular
    /// access logic in the chaincode)
    #[prost(bool, tag = "6")]
    pub member_only_read: bool,
    /// The member only write access denotes whether only collection member clients
    /// can write the private data (if set to true), or even non members can
    /// write the data (if set to false, for example if you want to implement more granular
    /// access logic in the chaincode)
    #[prost(bool, tag = "7")]
    pub member_only_write: bool,
    /// a reference to a policy residing / managed in the config block
    /// to define the endorsement policy for this collection
    #[prost(message, optional, tag = "8")]
    pub endorsement_policy: ::core::option::Option<ApplicationPolicy>,
}
/// Collection policy configuration. Initially, the configuration can only
/// contain a SignaturePolicy. In the future, the SignaturePolicy may be a
/// more general Policy. Instead of containing the actual policy, the
/// configuration may in the future contain a string reference to a policy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionPolicyConfig {
    #[prost(oneof = "collection_policy_config::Payload", tags = "1")]
    pub payload: ::core::option::Option<collection_policy_config::Payload>,
}
/// Nested message and enum types in `CollectionPolicyConfig`.
pub mod collection_policy_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Initially, only a signature policy is supported.
        ///
        /// Later, the SignaturePolicy will be replaced by a Policy.
        ///         Policy policy = 1;
        /// A reference to a Policy is planned to be added later.
        ///         string reference = 2;
        #[prost(message, tag = "1")]
        SignaturePolicy(super::SignaturePolicyEnvelope),
    }
}
/// HashingAlgorithm is encoded into the configuration transaction as a
/// configuration item of type Chain with a Key of "HashingAlgorithm" and a
/// Value of HashingAlgorithm as marshaled protobuf bytes
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HashingAlgorithm {
    /// SHA256 is currently the only supported and tested algorithm.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// BlockDataHashingStructure is encoded into the configuration transaction as a configuration item of
/// type Chain with a Key of "BlockDataHashingStructure" and a Value of HashingAlgorithm as marshaled protobuf bytes
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlockDataHashingStructure {
    /// width specifies the width of the Merkle tree to use when computing the BlockDataHash
    /// in order to replicate flat hashing, set this width to MAX_UINT32
    #[prost(uint32, tag = "1")]
    pub width: u32,
}
/// OrdererAddresses is encoded into the configuration transaction as a configuration item of type Chain
/// with a Key of "OrdererAddresses" and a Value of OrdererAddresses as marshaled protobuf bytes
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrdererAddresses {
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Consenter represents a consenting node (i.e. replica).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Consenter {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(string, tag = "2")]
    pub host: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub port: u32,
    #[prost(string, tag = "4")]
    pub msp_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub identity: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub client_tls_cert: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "7")]
    pub server_tls_cert: ::prost::alloc::vec::Vec<u8>,
}
/// Orderers is encoded into the configuration transaction as a configuration item of type Chain
/// with a Key of "Orderers" and a Value of Orderers as marshaled protobuf bytes
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Orderers {
    #[prost(message, repeated, tag = "1")]
    pub consenter_mapping: ::prost::alloc::vec::Vec<Consenter>,
}
/// Consortium represents the consortium context in which the channel was created
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Consortium {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Capabilities message defines the capabilities a particular binary must implement
/// for that binary to be able to safely participate in the channel.  The capabilities
/// message is defined at the /Channel level, the /Channel/Application level, and the
/// /Channel/Orderer level.
///
/// The /Channel level capabilties define capabilities which both the orderer and peer
/// binaries must satisfy.  These capabilties might be things like a new MSP type,
/// or a new policy type.
///
/// The /Channel/Orderer level capabilties define capabilities which must be supported
/// by the orderer, but which have no bearing on the behavior of the peer.  For instance
/// if the orderer changes the logic for how it constructs new channels, only all orderers
/// must agree on the new logic.  The peers do not need to be aware of this change as
/// they only interact with the channel after it has been constructed.
///
/// Finally, the /Channel/Application level capabilities define capabilities which the peer
/// binary must satisfy, but which have no bearing on the orderer.  For instance, if the
/// peer adds a new UTXO transaction type, or changes the chaincode lifecycle requirements,
/// all peers must agree on the new logic.  However, orderers never inspect transactions
/// this deeply, and therefore have no need to be aware of the change.
///
/// The capabilities strings defined in these messages typically correspond to release
/// binary versions (e.g. "V1.1"), and are used primarilly as a mechanism for a fully
/// upgraded network to switch from one set of logic to a new one.
///
/// Although for V1.1, the orderers must be upgraded to V1.1 prior to the rest of the
/// network, going forward, because of the split between the /Channel, /Channel/Orderer
/// and /Channel/Application capabilities.  It should be possible for the orderer and
/// application networks to upgrade themselves independently (with the exception of any
/// new capabilities defined at the /Channel level).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Capabilities {
    #[prost(map = "string, message", tag = "1")]
    pub capabilities: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        Capability,
    >,
}
/// Capability is an empty message for the time being.  It is defined as a protobuf
/// message rather than a constant, so that we may extend capabilities with other fields
/// if the need arises in the future.  For the time being, a capability being in the
/// capabilities map requires that that capability be supported.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Capability {}
/// Contains information about the blockchain ledger such as height, current
/// block hash, and previous block hash.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockchainInfo {
    #[prost(uint64, tag = "1")]
    pub height: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub current_block_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub previous_block_hash: ::prost::alloc::vec::Vec<u8>,
    /// Specifies bootstrapping snapshot info if the channel is bootstrapped from a snapshot.
    /// It is nil if the channel is not bootstrapped from a snapshot.
    #[prost(message, optional, tag = "4")]
    pub bootstrapping_snapshot_info: ::core::option::Option<BootstrappingSnapshotInfo>,
}
/// Contains information for the bootstrapping snapshot.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BootstrappingSnapshotInfo {
    #[prost(uint64, tag = "1")]
    pub last_block_in_snapshot: u64,
}
