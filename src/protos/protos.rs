// This file is @generated by prost-build.
/// ChaincodeIdentifier identifies a piece of chaincode.  For a peer to accept invocations of
/// this chaincode, the hash of the installed code must match, as must the version string
/// included with the install command.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeIdentifier {
    /// The hash of the chaincode bytes
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// A user friendly human readable name corresponding to the ID
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
/// ChaincodeValidation instructs the peer how transactions for this chaincode should be
/// validated.  The only validation mechanism which ships with fabric today is the standard
/// 'vscc' validation mechanism.  This built in validation method utilizes an endorsement policy
/// which checks that a sufficient number of signatures have been included.  The 'arguement'
/// field encodes any parameters required by the validation implementation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeValidation {
    /// Specifies which code to run to validate transactions, defaults to 'vscc'
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// When 'vscc' a marshaled VSCCArgs
    #[prost(bytes = "vec", tag = "2")]
    pub argument: ::prost::alloc::vec::Vec<u8>,
}
/// VSCCArgs is passed (marshaled) as a parameter to the VSCC imlementation via the
/// argument field of the ChaincodeValidation message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VsccArgs {
    /// A named reference to an endorsement policy,
    #[prost(string, tag = "1")]
    pub endorsement_policy_ref: ::prost::alloc::string::String,
}
/// ChaincodeEndorsement instructs the peer how transactions should be endorsed.  The only
/// endorsement mechanism which ships with the fabric today is the standard 'escc' mechanism.
/// This code simply simulates the proposal to generate a RW set, then signs the result
/// using the peer's local signing identity.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeEndorsement {
    /// Specifies what code to run for endorsements, defaults 'escc'
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// ConfigTree encapsulates channel and resources configuration of a channel.
/// Both configurations are represented as common.Config
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigTree {
    #[prost(message, optional, tag = "1")]
    pub channel_config: ::core::option::Option<super::common::Config>,
    #[prost(message, optional, tag = "2")]
    pub resources_config: ::core::option::Option<super::common::Config>,
}
/// A ProposalResponse is returned from an endorser to the proposal submitter.
/// The idea is that this message contains the endorser's response to the
/// request of a client to perform an action over a chaincode (or more
/// generically on the ledger); the response might be success/error (conveyed in
/// the Response field) together with a description of the action and a
/// signature over it by that endorser.  If a sufficient number of distinct
/// endorsers agree on the same action and produce signature to that effect, a
/// transaction can be generated and sent for ordering.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalResponse {
    /// Version indicates message protocol version
    #[prost(int32, tag = "1")]
    pub version: i32,
    /// Timestamp is the time that the message
    /// was created as  defined by the sender
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// A response message indicating whether the
    /// endorsement of the action was successful
    #[prost(message, optional, tag = "4")]
    pub response: ::core::option::Option<Response>,
    /// The payload of response. It is the bytes of ProposalResponsePayload
    #[prost(bytes = "vec", tag = "5")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// The endorsement of the proposal, basically
    /// the endorser's signature over the payload
    #[prost(message, optional, tag = "6")]
    pub endorsement: ::core::option::Option<Endorsement>,
    /// The chaincode interest derived from simulating the proposal.
    #[prost(message, optional, tag = "7")]
    pub interest: ::core::option::Option<ChaincodeInterest>,
}
/// A response with a representation similar to an HTTP response that can
/// be used within another message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    /// A status code that should follow the HTTP status codes.
    #[prost(int32, tag = "1")]
    pub status: i32,
    /// A message associated with the response code.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// A payload that can be used to include metadata with this response.
    #[prost(bytes = "vec", tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// ProposalResponsePayload is the payload of a proposal response.  This message
/// is the "bridge" between the client's request and the endorser's action in
/// response to that request. Concretely, for chaincodes, it contains a hashed
/// representation of the proposal (proposalHash) and a representation of the
/// chaincode state changes and events inside the extension field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalResponsePayload {
    /// Hash of the proposal that triggered this response. The hash is used to
    /// link a response with its proposal, both for bookeeping purposes on an
    /// asynchronous system and for security reasons (accountability,
    /// non-repudiation). The hash usually covers the entire Proposal message
    /// (byte-by-byte).
    #[prost(bytes = "vec", tag = "1")]
    pub proposal_hash: ::prost::alloc::vec::Vec<u8>,
    /// Extension should be unmarshaled to a type-specific message. The type of
    /// the extension in any proposal response depends on the type of the proposal
    /// that the client selected when the proposal was initially sent out.  In
    /// particular, this information is stored in the type field of a Header.  For
    /// chaincode, it's a ChaincodeAction message
    #[prost(bytes = "vec", tag = "2")]
    pub extension: ::prost::alloc::vec::Vec<u8>,
}
/// An endorsement is a signature of an endorser over a proposal response.  By
/// producing an endorsement message, an endorser implicitly "approves" that
/// proposal response and the actions contained therein. When enough
/// endorsements have been collected, a transaction can be generated out of a
/// set of proposal responses.  Note that this message only contains an identity
/// and a signature but no signed payload. This is intentional because
/// endorsements are supposed to be collected in a transaction, and they are all
/// expected to endorse a single proposal response/action (many endorsements
/// over a single proposal response)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Endorsement {
    /// Identity of the endorser (e.g. its certificate)
    #[prost(bytes = "vec", tag = "1")]
    pub endorser: ::prost::alloc::vec::Vec<u8>,
    /// Signature of the payload included in ProposalResponse concatenated with
    /// the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeInterest defines an interest about an endorsement
/// for a specific single chaincode invocation.
/// Multiple chaincodes indicate chaincode to chaincode invocations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeInterest {
    #[prost(message, repeated, tag = "1")]
    pub chaincodes: ::prost::alloc::vec::Vec<ChaincodeCall>,
}
/// ChaincodeCall defines a call to a chaincode.
/// It may have collections that are related to the chaincode
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeCall {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub collection_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Indicates we do not need to read from private data
    #[prost(bool, tag = "3")]
    pub no_private_reads: bool,
    /// Indicates we do not need to write to the chaincode namespace
    #[prost(bool, tag = "4")]
    pub no_public_writes: bool,
    /// The set of signature policies associated with states in the write-set
    /// that have state-based endorsement policies.
    #[prost(message, repeated, tag = "5")]
    pub key_policies: ::prost::alloc::vec::Vec<super::common::SignaturePolicyEnvelope>,
    /// Indicates we wish to ignore the namespace endorsement policy
    #[prost(bool, tag = "6")]
    pub disregard_namespace_policy: bool,
}
/// SignedChaincodeDeploymentSpec carries the CDS along with endorsements
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedChaincodeDeploymentSpec {
    /// This is the bytes of the ChaincodeDeploymentSpec
    #[prost(bytes = "vec", tag = "1")]
    pub chaincode_deployment_spec: ::prost::alloc::vec::Vec<u8>,
    /// This is the instantiation policy which is identical in structure
    /// to endorsement policy.  This policy is checked by the VSCC at commit
    /// time on the instantiation (all peers will get the same policy as it
    /// will be part of the LSCC instantation record and will be part of the
    /// hash as well)
    #[prost(bytes = "vec", tag = "2")]
    pub instantiation_policy: ::prost::alloc::vec::Vec<u8>,
    /// The endorsements of the above deployment spec, the owner's signature over
    /// chaincode_deployment_spec and Endorsement.endorser.
    #[prost(message, repeated, tag = "3")]
    pub owner_endorsements: ::prost::alloc::vec::Vec<Endorsement>,
}
/// ApplicationPolicy captures the diffenrent policy types that
/// are set and evaluted at the application level.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationPolicy {
    #[prost(oneof = "application_policy::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<application_policy::Type>,
}
/// Nested message and enum types in `ApplicationPolicy`.
pub mod application_policy {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// SignaturePolicy type is used if the policy is specified as
        /// a combination (using threshold gates) of signatures from MSP
        /// principals
        #[prost(message, tag = "1")]
        SignaturePolicy(super::super::common::SignaturePolicyEnvelope),
        /// ChannelConfigPolicyReference is used when the policy is
        /// specified as a string that references a policy defined in
        /// the configuration of the channel
        #[prost(string, tag = "2")]
        ChannelConfigPolicyReference(::prost::alloc::string::String),
    }
}
/// CollectionConfigPackage represents an array of CollectionConfig
/// messages; the extra struct is required because repeated oneof is
/// forbidden by the protobuf syntax
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionConfigPackage {
    #[prost(message, repeated, tag = "1")]
    pub config: ::prost::alloc::vec::Vec<CollectionConfig>,
}
/// CollectionConfig defines the configuration of a collection object;
/// it currently contains a single, static type.
/// Dynamic collections are deferred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionConfig {
    #[prost(oneof = "collection_config::Payload", tags = "1")]
    pub payload: ::core::option::Option<collection_config::Payload>,
}
/// Nested message and enum types in `CollectionConfig`.
pub mod collection_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        StaticCollectionConfig(super::StaticCollectionConfig),
    }
}
/// StaticCollectionConfig constitutes the configuration parameters of a
/// static collection object. Static collections are collections that are
/// known at chaincode instantiation time, and that cannot be changed.
/// Dynamic collections are deferred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StaticCollectionConfig {
    /// the name of the collection inside the denoted chaincode
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// a reference to a policy residing / managed in the config block
    /// to define which orgs have access to this collection’s private data
    #[prost(message, optional, tag = "2")]
    pub member_orgs_policy: ::core::option::Option<CollectionPolicyConfig>,
    /// The minimum number of peers private data will be sent to upon
    /// endorsement. The endorsement would fail if dissemination to at least
    /// this number of peers is not achieved.
    #[prost(int32, tag = "3")]
    pub required_peer_count: i32,
    /// The maximum number of peers that private data will be sent to
    /// upon endorsement. This number has to be bigger than required_peer_count.
    #[prost(int32, tag = "4")]
    pub maximum_peer_count: i32,
    /// The number of blocks after which the collection data expires.
    /// For instance if the value is set to 10, a key last modified by block number 100
    /// will be purged at block number 111. A zero value is treated same as MaxUint64
    #[prost(uint64, tag = "5")]
    pub block_to_live: u64,
    /// The member only read access denotes whether only collection member clients
    /// can read the private data (if set to true), or even non members can
    /// read the data (if set to false, for example if you want to implement more granular
    /// access logic in the chaincode)
    #[prost(bool, tag = "6")]
    pub member_only_read: bool,
    /// The member only write access denotes whether only collection member clients
    /// can write the private data (if set to true), or even non members can
    /// write the data (if set to false, for example if you want to implement more granular
    /// access logic in the chaincode)
    #[prost(bool, tag = "7")]
    pub member_only_write: bool,
    /// a reference to a policy residing / managed in the config block
    /// to define the endorsement policy for this collection
    #[prost(message, optional, tag = "8")]
    pub endorsement_policy: ::core::option::Option<ApplicationPolicy>,
}
/// Collection policy configuration. Initially, the configuration can only
/// contain a SignaturePolicy. In the future, the SignaturePolicy may be a
/// more general Policy. Instead of containing the actual policy, the
/// configuration may in the future contain a string reference to a policy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionPolicyConfig {
    #[prost(oneof = "collection_policy_config::Payload", tags = "1")]
    pub payload: ::core::option::Option<collection_policy_config::Payload>,
}
/// Nested message and enum types in `CollectionPolicyConfig`.
pub mod collection_policy_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Initially, only a signature policy is supported.
        ///
        /// Later, the SignaturePolicy will be replaced by a Policy.
        ///         Policy policy = 1;
        /// A reference to a Policy is planned to be added later.
        ///         string reference = 2;
        #[prost(message, tag = "1")]
        SignaturePolicy(super::super::common::SignaturePolicyEnvelope),
    }
}
/// ChaincodeQueryResponse returns information about each chaincode that pertains
/// to a query in lscc.go, such as GetChaincodes (returns all chaincodes
/// instantiated on a channel), and GetInstalledChaincodes (returns all chaincodes
/// installed on a peer)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeQueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub chaincodes: ::prost::alloc::vec::Vec<ChaincodeInfo>,
}
/// ChaincodeInfo contains general information about an installed/instantiated
/// chaincode
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// the path as specified by the install/instantiate transaction
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    /// the chaincode function upon instantiation and its arguments. This will be
    /// blank if the query is returning information about installed chaincodes.
    #[prost(string, tag = "4")]
    pub input: ::prost::alloc::string::String,
    /// the name of the ESCC for this chaincode. This will be
    /// blank if the query is returning information about installed chaincodes.
    #[prost(string, tag = "5")]
    pub escc: ::prost::alloc::string::String,
    /// the name of the VSCC for this chaincode. This will be
    /// blank if the query is returning information about installed chaincodes.
    #[prost(string, tag = "6")]
    pub vscc: ::prost::alloc::string::String,
    /// the chaincode unique id.
    /// computed as: H(
    ///                 H(name || version) ||
    ///                 H(CodePackage)
    ///               )
    #[prost(bytes = "vec", tag = "7")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
/// ChannelQueryResponse returns information about each channel that pertains
/// to a query in lscc.go, such as GetChannels (returns all channels for a
/// given peer)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelQueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub channels: ::prost::alloc::vec::Vec<ChannelInfo>,
}
/// ChannelInfo contains general information about channels
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelInfo {
    #[prost(string, tag = "1")]
    pub channel_id: ::prost::alloc::string::String,
}
/// JoinBySnapshotStatus contains information about whether or a JoinBySnapshot operation
/// is in progress and the related bootstrap dir if it is running.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinBySnapshotStatus {
    #[prost(bool, tag = "1")]
    pub in_progress: bool,
    #[prost(string, tag = "2")]
    pub bootstrapping_snapshot_dir: ::prost::alloc::string::String,
}
/// ChaincodeEvent is used for events and registrations that are specific to chaincode
/// string type - "chaincode"
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeEvent {
    #[prost(string, tag = "1")]
    pub chaincode_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub event_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeID contains the path as specified by the deploy transaction
/// that created it as well as the hashCode that is generated by the
/// system for the path. From the user level (ie, CLI, REST API and so on)
/// deploy transaction is expected to provide the path and other requests
/// are expected to provide the hashCode. The other value will be ignored.
/// Internally, the structure could contain both values. For instance, the
/// hashCode will be set when first generated using the path
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeId {
    /// deploy transaction will use the path
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// all other requests will use the name (really a hashcode) generated by
    /// the deploy transaction
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// user friendly version name for the chaincode
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
}
/// Carries the chaincode function and its arguments.
/// UnmarshalJSON in transaction.go converts the string-based REST/JSON input to
/// the \[\]byte-based current ChaincodeInput structure.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeInput {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(map = "string, bytes", tag = "2")]
    pub decorations:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    /// is_init is used for the application to signal that an invocation is to be routed
    /// to the legacy 'Init' function for compatibility with chaincodes which handled
    /// Init in the old way.  New applications should manage their initialized state
    /// themselves.
    #[prost(bool, tag = "3")]
    pub is_init: bool,
}
/// Carries the chaincode specification. This is the actual metadata required for
/// defining a chaincode.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeSpec {
    #[prost(enumeration = "chaincode_spec::Type", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub chaincode_id: ::core::option::Option<ChaincodeId>,
    #[prost(message, optional, tag = "3")]
    pub input: ::core::option::Option<ChaincodeInput>,
    #[prost(int32, tag = "4")]
    pub timeout: i32,
}
/// Nested message and enum types in `ChaincodeSpec`.
pub mod chaincode_spec {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Undefined = 0,
        Golang = 1,
        Node = 2,
        Car = 3,
        Java = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::Golang => "GOLANG",
                Self::Node => "NODE",
                Self::Car => "CAR",
                Self::Java => "JAVA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "GOLANG" => Some(Self::Golang),
                "NODE" => Some(Self::Node),
                "CAR" => Some(Self::Car),
                "JAVA" => Some(Self::Java),
                _ => None,
            }
        }
    }
}
/// Specify the deployment of a chaincode.
/// TODO: Define `codePackage`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeDeploymentSpec {
    #[prost(message, optional, tag = "1")]
    pub chaincode_spec: ::core::option::Option<ChaincodeSpec>,
    #[prost(bytes = "vec", tag = "3")]
    pub code_package: ::prost::alloc::vec::Vec<u8>,
}
/// Carries the chaincode function and its arguments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeInvocationSpec {
    #[prost(message, optional, tag = "1")]
    pub chaincode_spec: ::core::option::Option<ChaincodeSpec>,
}
/// LifecycleEvent is used as the payload of the chaincode event emitted by LSCC
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifecycleEvent {
    #[prost(string, tag = "1")]
    pub chaincode_name: ::prost::alloc::string::String,
}
/// CDSData is data stored in the LSCC on instantiation of a CC
/// for CDSPackage.  This needs to be serialized for ChaincodeData
/// hence the protobuf format
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CdsData {
    /// hash of ChaincodeDeploymentSpec.code_package
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// hash of ChaincodeID.name + ChaincodeID.version
    #[prost(bytes = "vec", tag = "2")]
    pub metadatahash: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeData defines the datastructure for chaincodes to be serialized by proto
/// Type provides an additional check by directing to use a specific package after instantiation
/// Data is Type specific (see CDSPackage and SignedCDSPackage)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeData {
    /// Name of the chaincode
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Version of the chaincode
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Escc for the chaincode instance
    #[prost(string, tag = "3")]
    pub escc: ::prost::alloc::string::String,
    /// Vscc for the chaincode instance
    #[prost(string, tag = "4")]
    pub vscc: ::prost::alloc::string::String,
    /// Policy endorsement policy for the chaincode instance
    #[prost(message, optional, tag = "5")]
    pub policy: ::core::option::Option<super::common::SignaturePolicyEnvelope>,
    /// Data data specific to the package
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Id of the chaincode that's the unique fingerprint for the CC This is not
    /// currently used anywhere but serves as a good eyecatcher
    #[prost(bytes = "vec", tag = "7")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// InstantiationPolicy for the chaincode
    #[prost(message, optional, tag = "8")]
    pub instantiation_policy: ::core::option::Option<super::common::SignaturePolicyEnvelope>,
}
/// ChaincodeAdditionalParams - parameters passed to chaincode to notify about peer capabilities
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChaincodeAdditionalParams {
    /// an indication that the peer can handle state write batches
    #[prost(bool, tag = "1")]
    pub use_write_batch: bool,
    /// maximum size of batches with write state
    #[prost(uint32, tag = "2")]
    pub max_size_write_batch: u32,
    /// an indication that the peer can handle get multiple keys
    #[prost(bool, tag = "3")]
    pub use_get_multiple_keys: bool,
    /// maximum size of batches with get multiple keys
    #[prost(uint32, tag = "4")]
    pub max_size_get_multiple_keys: u32,
}
/// This structure is necessary to sign the proposal which contains the header
/// and the payload. Without this structure, we would have to concatenate the
/// header and the payload to verify the signature, which could be expensive
/// with large payload
///
/// When an endorser receives a SignedProposal message, it should verify the
/// signature over the proposal bytes. This verification requires the following
/// steps:
/// 1. Verification of the validity of the certificate that was used to produce
///     the signature.  The certificate will be available once proposalBytes has
///     been unmarshalled to a Proposal message, and Proposal.header has been
///     unmarshalled to a Header message. While this unmarshalling-before-verifying
///     might not be ideal, it is unavoidable because i) the signature needs to also
///     protect the signing certificate; ii) it is desirable that Header is created
///     once by the client and never changed (for the sake of accountability and
///     non-repudiation). Note also that it is actually impossible to conclusively
///     verify the validity of the certificate included in a Proposal, because the
///     proposal needs to first be endorsed and ordered with respect to certificate
///     expiration transactions. Still, it is useful to pre-filter expired
///     certificates at this stage.
/// 2. Verification that the certificate is trusted (signed by a trusted CA) and
///     that it is allowed to transact with us (with respect to some ACLs);
/// 3. Verification that the signature on proposalBytes is valid;
/// 4. Detect replay attacks;
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedProposal {
    /// The bytes of Proposal
    #[prost(bytes = "vec", tag = "1")]
    pub proposal_bytes: ::prost::alloc::vec::Vec<u8>,
    /// Signaure over proposalBytes; this signature is to be verified against
    /// the creator identity contained in the header of the Proposal message
    /// marshaled as proposalBytes
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// A Proposal is sent to an endorser for endorsement.  The proposal contains:
/// 1. A header which should be unmarshaled to a Header message.  Note that
///     Header is both the header of a Proposal and of a Transaction, in that i)
///     both headers should be unmarshaled to this message; and ii) it is used to
///     compute cryptographic hashes and signatures.  The header has fields common
///     to all proposals/transactions.  In addition it has a type field for
///     additional customization. An example of this is the ChaincodeHeaderExtension
///     message used to extend the Header for type CHAINCODE.
/// 2. A payload whose type depends on the header's type field.
/// 3. An extension whose type depends on the header's type field.
///
/// Let us see an example. For type CHAINCODE (see the Header message),
/// we have the following:
/// 1. The header is a Header message whose extensions field is a
///     ChaincodeHeaderExtension message.
/// 2. The payload is a ChaincodeProposalPayload message.
/// 3. The extension is a ChaincodeAction that might be used to ask the
///     endorsers to endorse a specific ChaincodeAction, thus emulating the
///     submitting peer model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Proposal {
    /// The header of the proposal. It is the bytes of the Header
    #[prost(bytes = "vec", tag = "1")]
    pub header: ::prost::alloc::vec::Vec<u8>,
    /// The payload of the proposal as defined by the type in the proposal
    /// header.
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    /// Optional extensions to the proposal. Its content depends on the Header's
    /// type field.  For the type CHAINCODE, it might be the bytes of a
    /// ChaincodeAction message.
    #[prost(bytes = "vec", tag = "3")]
    pub extension: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeHeaderExtension is the Header's extentions message to be used when
/// the Header's type is CHAINCODE.  This extensions is used to specify which
/// chaincode to invoke and what should appear on the ledger.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeHeaderExtension {
    /// The ID of the chaincode to target.
    #[prost(message, optional, tag = "2")]
    pub chaincode_id: ::core::option::Option<ChaincodeId>,
}
/// ChaincodeProposalPayload is the Proposal's payload message to be used when
/// the Header's type is CHAINCODE.  It contains the arguments for this
/// invocation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeProposalPayload {
    /// Input contains the arguments for this invocation. If this invocation
    /// deploys a new chaincode, ESCC/VSCC are part of this field.
    /// This is usually a marshaled ChaincodeInvocationSpec
    #[prost(bytes = "vec", tag = "1")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// TransientMap contains data (e.g. cryptographic material) that might be used
    /// to implement some form of application-level confidentiality. The contents
    /// of this field are supposed to always be omitted from the transaction and
    /// excluded from the ledger.
    #[prost(map = "string, bytes", tag = "2")]
    pub transient_map:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
}
/// ChaincodeAction contains the executed chaincode results, response, and event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeAction {
    /// This field contains the read set and the write set produced by the
    /// chaincode executing this invocation.
    #[prost(bytes = "vec", tag = "1")]
    pub results: ::prost::alloc::vec::Vec<u8>,
    /// This field contains the event generated by the chaincode.
    /// Only a single marshaled ChaincodeEvent is included.
    #[prost(bytes = "vec", tag = "2")]
    pub events: ::prost::alloc::vec::Vec<u8>,
    /// This field contains the result of executing this invocation.
    #[prost(message, optional, tag = "3")]
    pub response: ::core::option::Option<Response>,
    /// This field contains the ChaincodeID of executing this invocation. Endorser
    /// will set it with the ChaincodeID called by endorser while simulating proposal.
    /// Committer will validate the version matching with latest chaincode version.
    /// Adding ChaincodeID to keep version opens up the possibility of multiple
    /// ChaincodeAction per transaction.
    #[prost(message, optional, tag = "4")]
    pub chaincode_id: ::core::option::Option<ChaincodeId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeMessage {
    #[prost(enumeration = "chaincode_message::Type", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bytes = "vec", tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub proposal: ::core::option::Option<SignedProposal>,
    /// event emitted by chaincode. Used only with Init or Invoke.
    /// This event is then stored (currently)
    /// with Block.NonHashData.TransactionResult
    #[prost(message, optional, tag = "6")]
    pub chaincode_event: ::core::option::Option<ChaincodeEvent>,
    /// channel id
    #[prost(string, tag = "7")]
    pub channel_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ChaincodeMessage`.
pub mod chaincode_message {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Undefined = 0,
        Register = 1,
        Registered = 2,
        Init = 3,
        Ready = 4,
        Transaction = 5,
        Completed = 6,
        Error = 7,
        GetState = 8,
        PutState = 9,
        DelState = 10,
        InvokeChaincode = 11,
        Response = 13,
        GetStateByRange = 14,
        GetQueryResult = 15,
        QueryStateNext = 16,
        QueryStateClose = 17,
        Keepalive = 18,
        GetHistoryForKey = 19,
        GetStateMetadata = 20,
        PutStateMetadata = 21,
        GetPrivateDataHash = 22,
        PurgePrivateData = 23,
        WriteBatchState = 24,
        GetStateMultiple = 25,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::Register => "REGISTER",
                Self::Registered => "REGISTERED",
                Self::Init => "INIT",
                Self::Ready => "READY",
                Self::Transaction => "TRANSACTION",
                Self::Completed => "COMPLETED",
                Self::Error => "ERROR",
                Self::GetState => "GET_STATE",
                Self::PutState => "PUT_STATE",
                Self::DelState => "DEL_STATE",
                Self::InvokeChaincode => "INVOKE_CHAINCODE",
                Self::Response => "RESPONSE",
                Self::GetStateByRange => "GET_STATE_BY_RANGE",
                Self::GetQueryResult => "GET_QUERY_RESULT",
                Self::QueryStateNext => "QUERY_STATE_NEXT",
                Self::QueryStateClose => "QUERY_STATE_CLOSE",
                Self::Keepalive => "KEEPALIVE",
                Self::GetHistoryForKey => "GET_HISTORY_FOR_KEY",
                Self::GetStateMetadata => "GET_STATE_METADATA",
                Self::PutStateMetadata => "PUT_STATE_METADATA",
                Self::GetPrivateDataHash => "GET_PRIVATE_DATA_HASH",
                Self::PurgePrivateData => "PURGE_PRIVATE_DATA",
                Self::WriteBatchState => "WRITE_BATCH_STATE",
                Self::GetStateMultiple => "GET_STATE_MULTIPLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "REGISTER" => Some(Self::Register),
                "REGISTERED" => Some(Self::Registered),
                "INIT" => Some(Self::Init),
                "READY" => Some(Self::Ready),
                "TRANSACTION" => Some(Self::Transaction),
                "COMPLETED" => Some(Self::Completed),
                "ERROR" => Some(Self::Error),
                "GET_STATE" => Some(Self::GetState),
                "PUT_STATE" => Some(Self::PutState),
                "DEL_STATE" => Some(Self::DelState),
                "INVOKE_CHAINCODE" => Some(Self::InvokeChaincode),
                "RESPONSE" => Some(Self::Response),
                "GET_STATE_BY_RANGE" => Some(Self::GetStateByRange),
                "GET_QUERY_RESULT" => Some(Self::GetQueryResult),
                "QUERY_STATE_NEXT" => Some(Self::QueryStateNext),
                "QUERY_STATE_CLOSE" => Some(Self::QueryStateClose),
                "KEEPALIVE" => Some(Self::Keepalive),
                "GET_HISTORY_FOR_KEY" => Some(Self::GetHistoryForKey),
                "GET_STATE_METADATA" => Some(Self::GetStateMetadata),
                "PUT_STATE_METADATA" => Some(Self::PutStateMetadata),
                "GET_PRIVATE_DATA_HASH" => Some(Self::GetPrivateDataHash),
                "PURGE_PRIVATE_DATA" => Some(Self::PurgePrivateData),
                "WRITE_BATCH_STATE" => Some(Self::WriteBatchState),
                "GET_STATE_MULTIPLE" => Some(Self::GetStateMultiple),
                _ => None,
            }
        }
    }
}
/// GetState is the payload of a ChaincodeMessage. It contains a key which
/// is to be fetched from the ledger. If the collection is specified, the key
/// would be fetched from the collection (i.e., private state)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetState {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateMetadata {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
/// GetStateMultiple is the payload of the ChaincodeMessage.
/// It contains the keys to be retrieved from the ledger.
/// If a collection is specified, the keys will be retrieved
/// from the collection (i.e., the private state).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateMultiple {
    #[prost(string, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
/// GetStateMultipleResult is result of executing the GetStateMiltiple request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateMultipleResult {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// PutState is the payload of a ChaincodeMessage. It contains a key and value
/// which needs to be written to the transaction's write set. If the collection is
/// specified, the key and value would be written to the transaction's private
/// write set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutState {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutStateMetadata {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<StateMetadata>,
}
/// WriteBatchState - set of records for state changes sent by the batch
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteBatchState {
    #[prost(message, repeated, tag = "1")]
    pub rec: ::prost::alloc::vec::Vec<WriteRecord>,
}
/// WriteRecord - single record with changes in the state of different types.
/// Filled in depending on the type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRecord {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<StateMetadata>,
    #[prost(enumeration = "write_record::Type", tag = "5")]
    pub r#type: i32,
}
/// Nested message and enum types in `WriteRecord`.
pub mod write_record {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Undefined = 0,
        PutState = 9,
        DelState = 10,
        PutStateMetadata = 21,
        PurgePrivateData = 23,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "UNDEFINED",
                Self::PutState => "PUT_STATE",
                Self::DelState => "DEL_STATE",
                Self::PutStateMetadata => "PUT_STATE_METADATA",
                Self::PurgePrivateData => "PURGE_PRIVATE_DATA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED" => Some(Self::Undefined),
                "PUT_STATE" => Some(Self::PutState),
                "DEL_STATE" => Some(Self::DelState),
                "PUT_STATE_METADATA" => Some(Self::PutStateMetadata),
                "PURGE_PRIVATE_DATA" => Some(Self::PurgePrivateData),
                _ => None,
            }
        }
    }
}
/// DelState is the payload of a ChaincodeMessage. It contains a key which
/// needs to be recorded in the transaction's write set as a delete operation.
/// If the collection is specified, the key needs to be recorded in the
/// transaction's private write set as a delete operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelState {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgePrivateState {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
}
/// GetStateByRange is the payload of a ChaincodeMessage. It contains a start key and
/// a end key required to execute range query. If the collection is specified,
/// the range query needs to be executed on the private data. The metadata hold
/// the byte representation of QueryMetadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateByRange {
    #[prost(string, tag = "1")]
    pub start_key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub end_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
/// GetQueryResult is the payload of a ChaincodeMessage. It contains a query
/// string in the form that is supported by the underlying state database.
/// If the collection is specified, the query needs to be executed on the
/// private data.  The metadata hold the byte representation of QueryMetadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQueryResult {
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
/// QueryMetadata is the metadata of a GetStateByRange and GetQueryResult.
/// It contains a pageSize which denotes the number of records to be fetched
/// and a bookmark.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMetadata {
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    #[prost(string, tag = "2")]
    pub bookmark: ::prost::alloc::string::String,
}
/// GetHistoryForKey is the payload of a ChaincodeMessage. It contains a key
/// for which the historical values need to be retrieved.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHistoryForKey {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStateNext {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStateClose {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// QueryResultBytes hold the byte representation of a record returned by the peer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResultBytes {
    #[prost(bytes = "vec", tag = "1")]
    pub result_bytes: ::prost::alloc::vec::Vec<u8>,
}
/// QueryResponse is returned by the peer as a result of a GetStateByRange,
/// GetQueryResult, and GetHistoryForKey. It holds a bunch of records in
/// results field, a flag to denote whether more results need to be fetched from
/// the peer in has_more field, transaction id in id field, and a QueryResponseMetadata
/// in metadata field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<QueryResultBytes>,
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
/// QueryResponseMetadata is the metadata of a QueryResponse. It contains a count
/// which denotes the number of records fetched from the ledger and a bookmark.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResponseMetadata {
    #[prost(int32, tag = "1")]
    pub fetched_records_count: i32,
    #[prost(string, tag = "2")]
    pub bookmark: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateMetadata {
    #[prost(string, tag = "1")]
    pub metakey: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateMetadataResult {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<StateMetadata>,
}
/// Generated client implementations.
pub mod chaincode_support_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Interface that provides support to chaincode execution. ChaincodeContext
    /// provides the context necessary for the server to respond appropriately.
    #[derive(Debug, Clone)]
    pub struct ChaincodeSupportClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ChaincodeSupportClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ChaincodeSupportClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::Body>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ChaincodeSupportClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn register(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ChaincodeMessage>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ChaincodeMessage>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.ChaincodeSupport/Register");
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.ChaincodeSupport", "Register"));
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod chaincode_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Chaincode as a server - peer establishes a connection to the chaincode as a client
    /// Currently only supports a stream connection.
    #[derive(Debug, Clone)]
    pub struct ChaincodeClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ChaincodeClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ChaincodeClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::Body>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ChaincodeClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn connect(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ChaincodeMessage>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ChaincodeMessage>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Chaincode/Connect");
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.Chaincode", "Connect"));
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod chaincode_support_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ChaincodeSupportServer.
    #[async_trait]
    pub trait ChaincodeSupport: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the Register method.
        type RegisterStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ChaincodeMessage, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn register(
            &self,
            request: tonic::Request<tonic::Streaming<super::ChaincodeMessage>>,
        ) -> std::result::Result<tonic::Response<Self::RegisterStream>, tonic::Status>;
    }
    /// Interface that provides support to chaincode execution. ChaincodeContext
    /// provides the context necessary for the server to respond appropriately.
    #[derive(Debug)]
    pub struct ChaincodeSupportServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ChaincodeSupportServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ChaincodeSupportServer<T>
    where
        T: ChaincodeSupport,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/protos.ChaincodeSupport/Register" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterSvc<T: ChaincodeSupport>(pub Arc<T>);
                    impl<T: ChaincodeSupport>
                        tonic::server::StreamingService<super::ChaincodeMessage>
                        for RegisterSvc<T>
                    {
                        type Response = super::ChaincodeMessage;
                        type ResponseStream = T::RegisterStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::ChaincodeMessage>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ChaincodeSupport>::register(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for ChaincodeSupportServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "protos.ChaincodeSupport";
    impl<T> tonic::server::NamedService for ChaincodeSupportServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod chaincode_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ChaincodeServer.
    #[async_trait]
    pub trait Chaincode: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the Connect method.
        type ConnectStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ChaincodeMessage, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn connect(
            &self,
            request: tonic::Request<tonic::Streaming<super::ChaincodeMessage>>,
        ) -> std::result::Result<tonic::Response<Self::ConnectStream>, tonic::Status>;
    }
    /// Chaincode as a server - peer establishes a connection to the chaincode as a client
    /// Currently only supports a stream connection.
    #[derive(Debug)]
    pub struct ChaincodeServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ChaincodeServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ChaincodeServer<T>
    where
        T: Chaincode,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/protos.Chaincode/Connect" => {
                    #[allow(non_camel_case_types)]
                    struct ConnectSvc<T: Chaincode>(pub Arc<T>);
                    impl<T: Chaincode> tonic::server::StreamingService<super::ChaincodeMessage> for ConnectSvc<T> {
                        type Response = super::ChaincodeMessage;
                        type ResponseStream = T::ConnectStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::ChaincodeMessage>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Chaincode>::connect(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ConnectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for ChaincodeServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "protos.Chaincode";
    impl<T> tonic::server::NamedService for ChaincodeServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// ProcessedTransaction wraps an Envelope that includes a transaction along with an indication
/// of whether the transaction was validated or invalidated by committing peer.
/// The use case is that GetTransactionByID API needs to retrieve the transaction Envelope
/// from block storage, and return it to a client, and indicate whether the transaction
/// was validated or invalidated by committing peer. So that the originally submitted
/// transaction Envelope is not modified, the ProcessedTransaction wrapper is returned.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessedTransaction {
    /// An Envelope which includes a processed transaction
    #[prost(message, optional, tag = "1")]
    pub transaction_envelope: ::core::option::Option<super::common::Envelope>,
    /// An indication of whether the transaction was validated or invalidated by committing peer
    #[prost(int32, tag = "2")]
    pub validation_code: i32,
}
/// The transaction to be sent to the ordering service. A transaction contains
/// one or more TransactionAction. Each TransactionAction binds a proposal to
/// potentially multiple actions. The transaction is atomic meaning that either
/// all actions in the transaction will be committed or none will.  Note that
/// while a Transaction might include more than one Header, the Header.creator
/// field must be the same in each.
/// A single client is free to issue a number of independent Proposal, each with
/// their header (Header) and request payload (ChaincodeProposalPayload).  Each
/// proposal is independently endorsed generating an action
/// (ProposalResponsePayload) with one signature per Endorser. Any number of
/// independent proposals (and their action) might be included in a transaction
/// to ensure that they are treated atomically.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// The payload is an array of TransactionAction. An array is necessary to
    /// accommodate multiple actions per transaction
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<TransactionAction>,
}
/// TransactionAction binds a proposal to its action.  The type field in the
/// header dictates the type of action to be applied to the ledger.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionAction {
    /// The header of the proposal action, which is the proposal header
    #[prost(bytes = "vec", tag = "1")]
    pub header: ::prost::alloc::vec::Vec<u8>,
    /// The payload of the action as defined by the type in the header For
    /// chaincode, it's the bytes of ChaincodeActionPayload
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// ChaincodeActionPayload is the message to be used for the TransactionAction's
/// payload when the Header's type is set to CHAINCODE.  It carries the
/// chaincodeProposalPayload and an endorsed action to apply to the ledger.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeActionPayload {
    /// This field contains the bytes of the ChaincodeProposalPayload message from
    /// the original invocation (essentially the arguments) after the application
    /// of the visibility function. The main visibility modes are "full" (the
    /// entire ChaincodeProposalPayload message is included here), "hash" (only
    /// the hash of the ChaincodeProposalPayload message is included) or
    /// "nothing".  This field will be used to check the consistency of
    /// ProposalResponsePayload.proposalHash.  For the CHAINCODE type,
    /// ProposalResponsePayload.proposalHash is supposed to be H(ProposalHeader ||
    /// f(ChaincodeProposalPayload)) where f is the visibility function.
    #[prost(bytes = "vec", tag = "1")]
    pub chaincode_proposal_payload: ::prost::alloc::vec::Vec<u8>,
    /// The list of actions to apply to the ledger
    #[prost(message, optional, tag = "2")]
    pub action: ::core::option::Option<ChaincodeEndorsedAction>,
}
/// ChaincodeEndorsedAction carries information about the endorsement of a
/// specific proposal
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChaincodeEndorsedAction {
    /// This is the bytes of the ProposalResponsePayload message signed by the
    /// endorsers.  Recall that for the CHAINCODE type, the
    /// ProposalResponsePayload's extenstion field carries a ChaincodeAction
    #[prost(bytes = "vec", tag = "1")]
    pub proposal_response_payload: ::prost::alloc::vec::Vec<u8>,
    /// The endorsement of the proposal, basically the endorser's signature over
    /// proposalResponsePayload
    #[prost(message, repeated, tag = "2")]
    pub endorsements: ::prost::alloc::vec::Vec<Endorsement>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TxValidationCode {
    Valid = 0,
    NilEnvelope = 1,
    BadPayload = 2,
    BadCommonHeader = 3,
    BadCreatorSignature = 4,
    InvalidEndorserTransaction = 5,
    InvalidConfigTransaction = 6,
    UnsupportedTxPayload = 7,
    BadProposalTxid = 8,
    DuplicateTxid = 9,
    EndorsementPolicyFailure = 10,
    MvccReadConflict = 11,
    PhantomReadConflict = 12,
    UnknownTxType = 13,
    TargetChainNotFound = 14,
    MarshalTxError = 15,
    NilTxaction = 16,
    ExpiredChaincode = 17,
    ChaincodeVersionConflict = 18,
    BadHeaderExtension = 19,
    BadChannelHeader = 20,
    BadResponsePayload = 21,
    BadRwset = 22,
    IllegalWriteset = 23,
    InvalidWriteset = 24,
    InvalidChaincode = 25,
    NotValidated = 254,
    InvalidOtherReason = 255,
}
impl TxValidationCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Valid => "VALID",
            Self::NilEnvelope => "NIL_ENVELOPE",
            Self::BadPayload => "BAD_PAYLOAD",
            Self::BadCommonHeader => "BAD_COMMON_HEADER",
            Self::BadCreatorSignature => "BAD_CREATOR_SIGNATURE",
            Self::InvalidEndorserTransaction => "INVALID_ENDORSER_TRANSACTION",
            Self::InvalidConfigTransaction => "INVALID_CONFIG_TRANSACTION",
            Self::UnsupportedTxPayload => "UNSUPPORTED_TX_PAYLOAD",
            Self::BadProposalTxid => "BAD_PROPOSAL_TXID",
            Self::DuplicateTxid => "DUPLICATE_TXID",
            Self::EndorsementPolicyFailure => "ENDORSEMENT_POLICY_FAILURE",
            Self::MvccReadConflict => "MVCC_READ_CONFLICT",
            Self::PhantomReadConflict => "PHANTOM_READ_CONFLICT",
            Self::UnknownTxType => "UNKNOWN_TX_TYPE",
            Self::TargetChainNotFound => "TARGET_CHAIN_NOT_FOUND",
            Self::MarshalTxError => "MARSHAL_TX_ERROR",
            Self::NilTxaction => "NIL_TXACTION",
            Self::ExpiredChaincode => "EXPIRED_CHAINCODE",
            Self::ChaincodeVersionConflict => "CHAINCODE_VERSION_CONFLICT",
            Self::BadHeaderExtension => "BAD_HEADER_EXTENSION",
            Self::BadChannelHeader => "BAD_CHANNEL_HEADER",
            Self::BadResponsePayload => "BAD_RESPONSE_PAYLOAD",
            Self::BadRwset => "BAD_RWSET",
            Self::IllegalWriteset => "ILLEGAL_WRITESET",
            Self::InvalidWriteset => "INVALID_WRITESET",
            Self::InvalidChaincode => "INVALID_CHAINCODE",
            Self::NotValidated => "NOT_VALIDATED",
            Self::InvalidOtherReason => "INVALID_OTHER_REASON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALID" => Some(Self::Valid),
            "NIL_ENVELOPE" => Some(Self::NilEnvelope),
            "BAD_PAYLOAD" => Some(Self::BadPayload),
            "BAD_COMMON_HEADER" => Some(Self::BadCommonHeader),
            "BAD_CREATOR_SIGNATURE" => Some(Self::BadCreatorSignature),
            "INVALID_ENDORSER_TRANSACTION" => Some(Self::InvalidEndorserTransaction),
            "INVALID_CONFIG_TRANSACTION" => Some(Self::InvalidConfigTransaction),
            "UNSUPPORTED_TX_PAYLOAD" => Some(Self::UnsupportedTxPayload),
            "BAD_PROPOSAL_TXID" => Some(Self::BadProposalTxid),
            "DUPLICATE_TXID" => Some(Self::DuplicateTxid),
            "ENDORSEMENT_POLICY_FAILURE" => Some(Self::EndorsementPolicyFailure),
            "MVCC_READ_CONFLICT" => Some(Self::MvccReadConflict),
            "PHANTOM_READ_CONFLICT" => Some(Self::PhantomReadConflict),
            "UNKNOWN_TX_TYPE" => Some(Self::UnknownTxType),
            "TARGET_CHAIN_NOT_FOUND" => Some(Self::TargetChainNotFound),
            "MARSHAL_TX_ERROR" => Some(Self::MarshalTxError),
            "NIL_TXACTION" => Some(Self::NilTxaction),
            "EXPIRED_CHAINCODE" => Some(Self::ExpiredChaincode),
            "CHAINCODE_VERSION_CONFLICT" => Some(Self::ChaincodeVersionConflict),
            "BAD_HEADER_EXTENSION" => Some(Self::BadHeaderExtension),
            "BAD_CHANNEL_HEADER" => Some(Self::BadChannelHeader),
            "BAD_RESPONSE_PAYLOAD" => Some(Self::BadResponsePayload),
            "BAD_RWSET" => Some(Self::BadRwset),
            "ILLEGAL_WRITESET" => Some(Self::IllegalWriteset),
            "INVALID_WRITESET" => Some(Self::InvalidWriteset),
            "INVALID_CHAINCODE" => Some(Self::InvalidChaincode),
            "NOT_VALIDATED" => Some(Self::NotValidated),
            "INVALID_OTHER_REASON" => Some(Self::InvalidOtherReason),
            _ => None,
        }
    }
}
/// Reserved entries in the key-level metadata map
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetaDataKeys {
    ValidationParameter = 0,
    ValidationParameterV2 = 1,
}
impl MetaDataKeys {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ValidationParameter => "VALIDATION_PARAMETER",
            Self::ValidationParameterV2 => "VALIDATION_PARAMETER_V2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALIDATION_PARAMETER" => Some(Self::ValidationParameter),
            "VALIDATION_PARAMETER_V2" => Some(Self::ValidationParameterV2),
            _ => None,
        }
    }
}
/// AnchorPeers simply represents list of anchor peers which is used in ConfigurationItem
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnchorPeers {
    #[prost(message, repeated, tag = "1")]
    pub anchor_peers: ::prost::alloc::vec::Vec<AnchorPeer>,
}
/// AnchorPeer message structure which provides information about anchor peer, it includes host name,
/// port number and peer certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnchorPeer {
    /// DNS host name of the anchor peer
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// The port number
    #[prost(int32, tag = "2")]
    pub port: i32,
}
/// APIResource represents an API resource in the peer whose ACL
/// is determined by the policy_ref field
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiResource {
    /// The policy name to use for this API
    #[prost(string, tag = "1")]
    pub policy_ref: ::prost::alloc::string::String,
}
/// ACLs provides mappings for resources in a channel. APIResource encapsulates
/// reference to a policy used to determine ACL for the resource
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcLs {
    #[prost(map = "string, message", tag = "1")]
    pub acls: ::std::collections::HashMap<::prost::alloc::string::String, ApiResource>,
}
/// FilteredBlock is a minimal set of information about a block
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilteredBlock {
    #[prost(string, tag = "1")]
    pub channel_id: ::prost::alloc::string::String,
    /// The position in the blockchain
    #[prost(uint64, tag = "2")]
    pub number: u64,
    #[prost(message, repeated, tag = "4")]
    pub filtered_transactions: ::prost::alloc::vec::Vec<FilteredTransaction>,
}
/// FilteredTransaction is a minimal set of information about a transaction
/// within a block
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilteredTransaction {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(enumeration = "super::common::HeaderType", tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "TxValidationCode", tag = "3")]
    pub tx_validation_code: i32,
    #[prost(oneof = "filtered_transaction::Data", tags = "4")]
    pub data: ::core::option::Option<filtered_transaction::Data>,
}
/// Nested message and enum types in `FilteredTransaction`.
pub mod filtered_transaction {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "4")]
        TransactionActions(super::FilteredTransactionActions),
    }
}
/// FilteredTransactionActions is a wrapper for array of TransactionAction
/// message from regular block
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilteredTransactionActions {
    #[prost(message, repeated, tag = "1")]
    pub chaincode_actions: ::prost::alloc::vec::Vec<FilteredChaincodeAction>,
}
/// FilteredChaincodeAction is a minimal set of information about an action
/// within a transaction
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilteredChaincodeAction {
    #[prost(message, optional, tag = "1")]
    pub chaincode_event: ::core::option::Option<ChaincodeEvent>,
}
/// BlockAndPrivateData contains Block and a map from tx_seq_in_block to rwset.TxPvtReadWriteSet
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockAndPrivateData {
    #[prost(message, optional, tag = "1")]
    pub block: ::core::option::Option<super::common::Block>,
    /// map from tx_seq_in_block to rwset.TxPvtReadWriteSet
    #[prost(map = "uint64, message", tag = "2")]
    pub private_data_map: ::std::collections::HashMap<u64, super::rwset::TxPvtReadWriteSet>,
}
/// DeliverResponse
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliverResponse {
    #[prost(oneof = "deliver_response::Type", tags = "1, 2, 3, 4")]
    pub r#type: ::core::option::Option<deliver_response::Type>,
}
/// Nested message and enum types in `DeliverResponse`.
pub mod deliver_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(enumeration = "super::super::common::Status", tag = "1")]
        Status(i32),
        #[prost(message, tag = "2")]
        Block(super::super::common::Block),
        #[prost(message, tag = "3")]
        FilteredBlock(super::FilteredBlock),
        #[prost(message, tag = "4")]
        BlockAndPrivateData(super::BlockAndPrivateData),
    }
}
/// Generated client implementations.
pub mod deliver_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct DeliverClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DeliverClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DeliverClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::Body>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DeliverClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with
        /// Payload data as a marshaled orderer.SeekInfo message,
        /// then a stream of block replies is received
        pub async fn deliver(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::super::common::Envelope>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DeliverResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Deliver/Deliver");
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.Deliver", "Deliver"));
            self.inner.streaming(req, path, codec).await
        }
        /// DeliverFiltered first requires an Envelope of type ab.DELIVER_SEEK_INFO with
        /// Payload data as a marshaled orderer.SeekInfo message,
        /// then a stream of **filtered** block replies is received
        pub async fn deliver_filtered(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::super::common::Envelope>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DeliverResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Deliver/DeliverFiltered");
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.Deliver", "DeliverFiltered"));
            self.inner.streaming(req, path, codec).await
        }
        /// DeliverWithPrivateData first requires an Envelope of type ab.DELIVER_SEEK_INFO with
        /// Payload data as a marshaled orderer.SeekInfo message,
        /// then a stream of block and private data replies is received
        pub async fn deliver_with_private_data(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::super::common::Envelope>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DeliverResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/protos.Deliver/DeliverWithPrivateData");
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.Deliver", "DeliverWithPrivateData"));
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod deliver_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with DeliverServer.
    #[async_trait]
    pub trait Deliver: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the Deliver method.
        type DeliverStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DeliverResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with
        /// Payload data as a marshaled orderer.SeekInfo message,
        /// then a stream of block replies is received
        async fn deliver(
            &self,
            request: tonic::Request<tonic::Streaming<super::super::common::Envelope>>,
        ) -> std::result::Result<tonic::Response<Self::DeliverStream>, tonic::Status>;
        /// Server streaming response type for the DeliverFiltered method.
        type DeliverFilteredStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DeliverResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// DeliverFiltered first requires an Envelope of type ab.DELIVER_SEEK_INFO with
        /// Payload data as a marshaled orderer.SeekInfo message,
        /// then a stream of **filtered** block replies is received
        async fn deliver_filtered(
            &self,
            request: tonic::Request<tonic::Streaming<super::super::common::Envelope>>,
        ) -> std::result::Result<tonic::Response<Self::DeliverFilteredStream>, tonic::Status>;
        /// Server streaming response type for the DeliverWithPrivateData method.
        type DeliverWithPrivateDataStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DeliverResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// DeliverWithPrivateData first requires an Envelope of type ab.DELIVER_SEEK_INFO with
        /// Payload data as a marshaled orderer.SeekInfo message,
        /// then a stream of block and private data replies is received
        async fn deliver_with_private_data(
            &self,
            request: tonic::Request<tonic::Streaming<super::super::common::Envelope>>,
        ) -> std::result::Result<tonic::Response<Self::DeliverWithPrivateDataStream>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct DeliverServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> DeliverServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for DeliverServer<T>
    where
        T: Deliver,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/protos.Deliver/Deliver" => {
                    #[allow(non_camel_case_types)]
                    struct DeliverSvc<T: Deliver>(pub Arc<T>);
                    impl<T: Deliver> tonic::server::StreamingService<super::super::common::Envelope> for DeliverSvc<T> {
                        type Response = super::DeliverResponse;
                        type ResponseStream = T::DeliverStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::super::common::Envelope>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move { <T as Deliver>::deliver(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeliverSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/protos.Deliver/DeliverFiltered" => {
                    #[allow(non_camel_case_types)]
                    struct DeliverFilteredSvc<T: Deliver>(pub Arc<T>);
                    impl<T: Deliver> tonic::server::StreamingService<super::super::common::Envelope>
                        for DeliverFilteredSvc<T>
                    {
                        type Response = super::DeliverResponse;
                        type ResponseStream = T::DeliverFilteredStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::super::common::Envelope>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Deliver>::deliver_filtered(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeliverFilteredSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/protos.Deliver/DeliverWithPrivateData" => {
                    #[allow(non_camel_case_types)]
                    struct DeliverWithPrivateDataSvc<T: Deliver>(pub Arc<T>);
                    impl<T: Deliver> tonic::server::StreamingService<super::super::common::Envelope>
                        for DeliverWithPrivateDataSvc<T>
                    {
                        type Response = super::DeliverResponse;
                        type ResponseStream = T::DeliverWithPrivateDataStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::super::common::Envelope>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Deliver>::deliver_with_private_data(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeliverWithPrivateDataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for DeliverServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "protos.Deliver";
    impl<T> tonic::server::NamedService for DeliverServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod endorser_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct EndorserClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> EndorserClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EndorserClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::Body>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            EndorserClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn process_proposal(
            &mut self,
            request: impl tonic::IntoRequest<super::SignedProposal>,
        ) -> std::result::Result<tonic::Response<super::ProposalResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Endorser/ProcessProposal");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.Endorser", "ProcessProposal"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod endorser_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with EndorserServer.
    #[async_trait]
    pub trait Endorser: std::marker::Send + std::marker::Sync + 'static {
        async fn process_proposal(
            &self,
            request: tonic::Request<super::SignedProposal>,
        ) -> std::result::Result<tonic::Response<super::ProposalResponse>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct EndorserServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> EndorserServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for EndorserServer<T>
    where
        T: Endorser,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/protos.Endorser/ProcessProposal" => {
                    #[allow(non_camel_case_types)]
                    struct ProcessProposalSvc<T: Endorser>(pub Arc<T>);
                    impl<T: Endorser> tonic::server::UnaryService<super::SignedProposal> for ProcessProposalSvc<T> {
                        type Response = super::ProposalResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignedProposal>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Endorser>::process_proposal(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ProcessProposalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for EndorserServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "protos.Endorser";
    impl<T> tonic::server::NamedService for EndorserServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// SnapshotRequest contains information for a generate/cancel snapshot request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotRequest {
    /// The signature header that contains creator identity and nonce
    #[prost(message, optional, tag = "1")]
    pub signature_header: ::core::option::Option<super::common::SignatureHeader>,
    /// The channel ID
    #[prost(string, tag = "2")]
    pub channel_id: ::prost::alloc::string::String,
    /// The block number to generate a snapshot
    #[prost(uint64, tag = "3")]
    pub block_number: u64,
}
/// SnapshotQuery contains information for a query snapshot request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotQuery {
    /// The signature header that contains creator identity and nonce
    #[prost(message, optional, tag = "1")]
    pub signature_header: ::core::option::Option<super::common::SignatureHeader>,
    /// The channel ID
    #[prost(string, tag = "2")]
    pub channel_id: ::prost::alloc::string::String,
}
/// SignedSnapshotRequest contains marshalled request bytes and signature
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedSnapshotRequest {
    /// The bytes of SnapshotRequest or SnapshotQuery
    #[prost(bytes = "vec", tag = "1")]
    pub request: ::prost::alloc::vec::Vec<u8>,
    /// Signaure over request bytes; this signature is to be verified against the client identity
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// QueryPendingSnapshotsResponse specifies the response payload of a query pending snapshots request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPendingSnapshotsResponse {
    #[prost(uint64, repeated, tag = "1")]
    pub block_numbers: ::prost::alloc::vec::Vec<u64>,
}
/// Generated client implementations.
pub mod snapshot_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct SnapshotClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SnapshotClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SnapshotClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::Body>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SnapshotClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Generate a snapshot reqeust. SignedSnapshotRequest contains marshalled bytes for SnaphostRequest
        pub async fn generate(
            &mut self,
            request: impl tonic::IntoRequest<super::SignedSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Snapshot/Generate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.Snapshot", "Generate"));
            self.inner.unary(req, path, codec).await
        }
        /// Cancel a snapshot reqeust. SignedSnapshotRequest contains marshalled bytes for SnaphostRequest
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::SignedSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Snapshot/Cancel");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.Snapshot", "Cancel"));
            self.inner.unary(req, path, codec).await
        }
        /// Query pending snapshots query. SignedSnapshotRequest contains marshalled bytes for SnaphostQuery
        pub async fn query_pendings(
            &mut self,
            request: impl tonic::IntoRequest<super::SignedSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryPendingSnapshotsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/protos.Snapshot/QueryPendings");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("protos.Snapshot", "QueryPendings"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod snapshot_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SnapshotServer.
    #[async_trait]
    pub trait Snapshot: std::marker::Send + std::marker::Sync + 'static {
        /// Generate a snapshot reqeust. SignedSnapshotRequest contains marshalled bytes for SnaphostRequest
        async fn generate(
            &self,
            request: tonic::Request<super::SignedSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Cancel a snapshot reqeust. SignedSnapshotRequest contains marshalled bytes for SnaphostRequest
        async fn cancel(
            &self,
            request: tonic::Request<super::SignedSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Query pending snapshots query. SignedSnapshotRequest contains marshalled bytes for SnaphostQuery
        async fn query_pendings(
            &self,
            request: tonic::Request<super::SignedSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryPendingSnapshotsResponse>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct SnapshotServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SnapshotServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SnapshotServer<T>
    where
        T: Snapshot,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/protos.Snapshot/Generate" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateSvc<T: Snapshot>(pub Arc<T>);
                    impl<T: Snapshot> tonic::server::UnaryService<super::SignedSnapshotRequest> for GenerateSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignedSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as Snapshot>::generate(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/protos.Snapshot/Cancel" => {
                    #[allow(non_camel_case_types)]
                    struct CancelSvc<T: Snapshot>(pub Arc<T>);
                    impl<T: Snapshot> tonic::server::UnaryService<super::SignedSnapshotRequest> for CancelSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignedSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move { <T as Snapshot>::cancel(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CancelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/protos.Snapshot/QueryPendings" => {
                    #[allow(non_camel_case_types)]
                    struct QueryPendingsSvc<T: Snapshot>(pub Arc<T>);
                    impl<T: Snapshot> tonic::server::UnaryService<super::SignedSnapshotRequest>
                        for QueryPendingsSvc<T>
                    {
                        type Response = super::QueryPendingSnapshotsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignedSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Snapshot>::query_pendings(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryPendingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for SnapshotServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "protos.Snapshot";
    impl<T> tonic::server::NamedService for SnapshotServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
